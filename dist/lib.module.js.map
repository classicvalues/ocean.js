{"version":3,"file":"lib.module.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/pools/ssContracts/SideStaking.ts","../src/pools/Router.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/models/Config.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { Config } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { ZERO_ADDRESS } from './Constants'\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(web3: Web3, config: Config): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport function getFreOrderParams(freParams: FreOrderParams): any {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: Web3.utils.toWei(freParams.maxBaseTokenAmount),\n    swapMarketFee: Web3.utils.toWei(freParams.swapMarketFee),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const anchor = document.createElement('a')\n  anchor.download = ''\n  anchor.href = url\n  anchor.click()\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000',\n    providerUri: 'http://172.15.0.4:8030'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { GASLIMIT_DEFAULT } from '.'\nimport { Config } from '../models'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  const gasLimitDefault = GASLIMIT_DEFAULT\n  let estGas\n  try {\n    estGas = await tokenContract.methods\n      .approve(spender, amount)\n      .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n  } catch (e) {\n    estGas = gasLimitDefault\n    LoggerInstance.error('estimate gas failed for approve!', e)\n  }\n  return estGas\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount  (always expressed as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  config?: Config\n): Promise<TransactionReceipt | string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender, config)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowence\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await estApprove(\n    web3,\n    account,\n    tokenAddress,\n    spender,\n    amountFormatted,\n    tokenContract\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, config)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERRPR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  config?: Config\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  config?: Config\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(3.01)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2.01)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  private config: Config\n\n  constructor(web3: Web3, poolAbi: AbiItem | AbiItem[] = null, config?: Config) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .setSwapFee(fee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estSetSwapFee(account, poolAddress, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get OPC Collector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getOPCCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {String}\n   */\n  async getReserve(poolAddress: string, token: string): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getMarketFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getCommunityFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectOPC()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectOPC(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectMarketFee()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectMarketFee(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .updatePublishMarketFee(newPublishMarketAddress, newPublishMarketSwapFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estUpdatePublishMarketFee(\n      address,\n      poolAddress,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountIn(\n      address,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    let result = null\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountOut(\n      account,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinPool method\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinPool(poolAmountOut, maxAmountsIn)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Adds dual side liquidity to the pool (both datatoken and basetoken)\n   * This will pull some of each of the currently trading tokens in the pool,\n   * meaning you must have called approve for each token for this pool.\n   * These values are limited by the array of maxAmountsIn in the order of the pool tokens.\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @return {TransactionReceipt}\n   */\n  async joinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMaxAmountsIn = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], maxAmountsIn[i])\n      weiMaxAmountsIn.push(amount)\n    }\n\n    let result = null\n\n    const estGas = await this.estJoinPool(\n      address,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountOut),\n      weiMaxAmountsIn\n    )\n\n    try {\n      result = await pool.methods\n        .joinPool(this.web3.utils.toWei(poolAmountOut), weiMaxAmountsIn)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to join pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitPool\n   * @param {String} address\n   * @param {String} poolAddress\n ``* @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut  aarray with minimum amount of tokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitPool(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitPool(poolAmountIn, minAmountsOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes dual side liquidity from the pool (both datatoken and basetoken)\n   * Exit the pool, paying poolAmountIn pool tokens and getting some of each of the currently trading tokens in return.\n   * These values are limited by the array of minAmountsOut in the order of the pool tokens.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut array with minimum amount of tokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitPool(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMinAmountsOut = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], minAmountsOut[i])\n      weiMinAmountsOut.push(amount)\n    }\n    let result = null\n    const estGas = await this.estExitPool(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      weiMinAmountsOut\n    )\n\n    try {\n      result = await pool.methods\n        .exitPool(this.web3.utils.toWei(poolAmountIn), weiMinAmountsOut)\n        .send({\n          from: account,\n          gas: estGas,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to exit pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinswapExternAmountIn(tokenAmountIn, minPoolAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n    const estGas = await this.estJoinswapExternAmountIn(\n      account,\n      poolAddress,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitswapPoolAmountIn(poolAmountIn, minTokenAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await amountToUnits(\n      this.web3,\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut\n    )\n    const estGas = await this.estExitswapPoolAmountIn(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenIn)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountIn),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param _consumeMarketSwapFee consume market swap fee\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountOut),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await amountToUnits(this.web3, poolAddress, poolAmountOut)\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n\n        .call()\n\n      amount = await unitsToAmount(this.web3, tokenIn, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await amountToUnits(this.web3, poolAddress, poolAmountIn)\n        )\n        .call()\n      amount = await unitsToAmount(this.web3, tokenOut, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_SWAP' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_JOIN' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_EXIT' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public GASLIMIT_DEFAULT = 1000000\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.dispenserContract.methods\n        .create(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance),\n          address,\n          allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreate(\n      dtAddress,\n      address,\n      maxTokens,\n      maxBalance,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasActivate(dtAddress, maxTokens, maxBalance, address)\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .deactivate(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasDeactivate(dtAddress, address)\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasSetAllowedSwapper(\n        dtAddress,\n        address,\n        newAllowedSwapper\n      )\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasDispense(dtAddress, address, amount, destination)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasOwnerWithdraw(dtAddress, address)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount,\n  ZERO_ADDRESS\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  public GASLIMIT_DEFAULT = 1000000\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public fixedRateContract: Contract\n  public web3: Web3\n  public contract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    this.contract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(token: string, amount: string): Promise<string> {\n    return amountToUnits(this.web3, token, amount)\n  }\n\n  async unitsToAmount(token: string, amount: string): Promise<string> {\n    return unitsToAmount(this.web3, token, amount)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .buyDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount\n    )\n\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .sellDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount\n    )\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, await this.web3.utils.toWei(newRate))\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(address, exchangeId, newRate)\n    const trxReceipt = await this.contract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, newAllowedSwapper)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetAllowedSwapper(address, exchangeId, newAllowedSwapper)\n    const trxReceipt = await this.contract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n\n    const estGas = await this.estActivate(address, exchangeId)\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).datatoken,\n      dtSupply\n    )\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      btSupply\n    )\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(fixedRateExchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(exchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result[0]\n    )\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(result.datatoken, result.dtBalance)\n    result.btBalance = await this.unitsToAmount(result.baseToken, result.btBalance)\n    result.dtSupply = await this.unitsToAmount(result.datatoken, result.dtSupply)\n    result.btSupply = await this.unitsToAmount(result.baseToken, result.btSupply)\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    result.marketFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.marketFeeAvailable\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.oceanFeeAvailable\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.contract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId, true)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await this.estActivateMint(address, exchangeId)\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectBT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectBT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    const trxReceipt = await this.contract.methods.collectBT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectDT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectDT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    const trxReceipt = await this.contract.methods.collectDT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectMarketFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectMarketFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectOceanFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectOceanFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFee(exchangeId, newMarketFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(\n      address,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estUpdateMarketFeeCollector(\n      address,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport SideStakingTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport { Config } from '../../models'\n\nexport class SideStaking {\n  public ssAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  public config: Config\n\n  constructor(web3: Web3, ssAbi: AbiItem | AbiItem[] = null, config?: Config) {\n    if (ssAbi) this.ssAbi = ssAbi\n    else this.ssAbi = SideStakingTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  async amountToUnits(token: string, amount: string): Promise<string> {\n    let decimals = 18\n    const tokenContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], token),\n      this.config\n    )\n    try {\n      decimals = await tokenContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error('ERROR: FAILED TO CALL DECIMALS(), USING 18')\n    }\n\n    const amountFormatted = new BigNumber(parseInt(amount) * 10 ** decimals)\n\n    return amountFormatted.toString()\n  }\n\n  async unitsToAmount(token: string, amount: string): Promise<string> {\n    let decimals = 18\n    const tokenContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], token),\n      this.config\n    )\n    try {\n      decimals = await tokenContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error('ERROR: FAILED TO CALL DECIMALS(), USING 18')\n    }\n\n    const amountFormatted = new BigNumber(parseInt(amount) / 10 ** decimals)\n\n    return amountFormatted.toString()\n  }\n\n  /**\n   * Get (total vesting amount + token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods\n        .getDatatokenCirculatingSupply(datatokenAddress)\n        .call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result.toString()\n  }\n\n  /**\n   * Get actual dts in circulation (vested token withdrawn from the contract +\n         token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCurrentCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    try {\n      const sideStaking = setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi, ssAddress),\n        this.config\n      )\n      let result = null\n      result = await sideStaking.methods\n        .getDatatokenCurrentCirculatingSupply(datatokenAddress)\n        .call()\n      return result.toString()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n  }\n\n  /**\n   * Get Publisher address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getPublisherAddress(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getPublisherAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseToken(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Pool Address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getPoolAddress(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getPoolAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get baseToken balance in the contract\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseTokenBalance(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get dt balance in the staking contract available for being added as liquidity\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getDatatokenBalance(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getDatatokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result)\n    return result\n  }\n\n  /**\n   * Get block when vesting ends\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String} end block for vesting amount\n   */\n  async getvestingEndBlock(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingEndBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total amount vesting\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingAmount(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = new this.web3.eth.Contract(this.ssAbi, ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmount(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result)\n    return result\n  }\n\n  /**\n   * Get last block publisher got some vested tokens\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingLastBlock(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingLastBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get how much has been taken from the vesting amount\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingAmountSoFar(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmountSoFar(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result)\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estGetVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi as AbiItem[], ssAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await sideStaking.methods\n        .getVesting(datatokenAddress)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async getVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<TransactionReceipt> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estGetVesting(\n      account,\n      ssAddress,\n      datatokenAddress,\n      sideStaking\n    )\n    try {\n      result = await sideStaking.methods.getVesting(datatokenAddress).send({\n        from: account,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi as AbiItem[], ssAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async setPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number\n  ): Promise<TransactionReceipt> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estSetPoolSwapFee(\n      account,\n      ssAddress,\n      datatokenAddress,\n      poolAddress,\n      swapFee,\n      sideStaking\n    )\n    try {\n      result = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in side staking contract\n   * @param {String} ssAddress side staking contract address\n   * @return {String}\n   */\n  async getRouter(ssAddress: string): Promise<string> {\n    const sideStaking = setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await sideStaking.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { getFairGasPrice, setContractDefaults, configHelperNetworks } from '../utils'\nimport { Operation } from '../@types/Router'\nimport { Config } from '../models/index.js'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router {\n  public GASLIMIT_DEFAULT = 1000000\n  public routerAddress: string\n  public RouterAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public router: Contract\n\n  /**\n   * Instantiate Router.\n   * @param {String} routerAddress\n   * @param {AbiItem | AbiItem[]} Router\n   * @param {Web3} web3\n   */\n  constructor(\n    routerAddress: string,\n    web3: Web3,\n    RouterAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.routerAddress = routerAddress\n    this.RouterAbi = RouterAbi || (defaultRouter.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.router = setContractDefaults(\n      new this.web3.eth.Contract(this.RouterAbi, this.routerAddress),\n      this.config\n    )\n  }\n\n  /**\n   * Estimate gas cost for buyDTBatch method\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async estGasBuyDTBatch(address: string, operations: Operation[]): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .buyDTBatch(operations)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * BuyDTBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async buyDTBatch(\n    address: string,\n    operations: Operation[]\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasBuyDTBatch(address, operations)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.buyDTBatch(operations).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.router.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a side staking contract.\n   * @return {Promise<boolean>} true if is a SS contract\n   */\n  public async isSideStaking(address: string): Promise<boolean> {\n    return await this.router.methods.isSSContract(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.router.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.router.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.router.methods.factory().call()\n  }\n\n  /** Check if an address is a pool template contract.\n   * @return {Promise<boolean>} true if is a Template\n   */\n  public async isPoolTemplate(address: string): Promise<boolean> {\n    return await this.router.methods.isPoolTemplate(address).call()\n  }\n\n  /**\n   * Estimate gas cost for addApprovedToken\n   * @param {String} address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ) {\n    const routerContract = contractInstance || this.router\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await routerContract.methods\n        .addApprovedToken(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new token to oceanTokens list, pools with baseToken in this list have NO opf Fee\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddApprovedToken(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeApprovedToken\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ) {\n    const routerContract = contractInstance || this.router\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await routerContract.methods\n        .removeApprovedToken(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove a token from oceanTokens list, pools without baseToken in this list have a opf Fee\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveApprovedToken(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addSSContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddSSContract(address: string, tokenAddress: string): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addSSContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to ssContract list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddSSContract(address, tokenAddress)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeSSContract method\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeSSContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Removes a new contract from ssContract list\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to removed\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveSSContract(address, tokenAddress)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addFixedRateContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddFixedRateContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addFixedRateContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeFixedRateContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Removes a contract from fixedRate list\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveFixedRateContract(address, tokenAddress)\n\n    // Invoke removeFixedRateContract function of the contract\n    const trxReceipt = await this.router.methods\n      .removeFixedRateContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addDispenserContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddDispenserContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addDispenserContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeDispenserContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveDispenserContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removeDispenserContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.router.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.router.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Estimate gas cost for updateOPFFee method\n   * @param {String} address\n   * @param {String} newFee new OPF Fee\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasUpdateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async updateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasUpdateOPCFee(\n      address,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addPoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addPoolTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new template to poolTemplates mapping, after template is added,it can be used\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddPoolTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addPoolTemplate(templateAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removePoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemovePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removePoolTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove template from poolTemplates mapping, after template is removed,it can be used anymore\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemovePoolTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removePoolTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  configHelperNetworks\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(web3: Web3, nftAbi?: AbiItem | AbiItem[], config?: Config) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .createERC20(\n          templateIndex,\n          [name, symbol],\n          [minter, paymentCollector, mpFeeAddress, feeToken],\n          [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n          []\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCreateErc20(\n      nftAddress,\n      address,\n      minter,\n      paymentCollector,\n      mpFeeAddress,\n      feeToken,\n      feeAmount,\n      cap,\n      name,\n      symbol,\n      templateIndex,\n      nftContract\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasAddManager(nftAddress, address, manager, nftContract)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasRemoveManager(\n      nftAddress,\n      address,\n      manager,\n      nftContract\n    )\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToCreateERC20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await this.estGasAddErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromCreateErc20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await this.estGasRemoveErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addTo725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFrom725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await this.estGasRemoveStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasCleanPermissions(nftAddress, address, nftContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .transferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .safeTransferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasSafeTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaData(\n          metadataState,\n          metadataDecryptorUrl,\n          metadataDecryptorAddress,\n          flags,\n          data,\n          metadataHash,\n          metadataProofs\n        )\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      LoggerInstance.error('estGasSetMetadata error: ', e.message)\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadata(\n      nftAddress,\n      address,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs,\n      nftContract\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadataAndTokenURI(\n      nftAddress,\n      metadataUpdater,\n      metadataAndTokenURI,\n      nftContract\n    )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataState(metadataState)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await this.estGasSetMetadataState(nftAddress, address, metadataState)\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setTokenURI('1', data)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estSetTokenURI(nftAddress, address, data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.getData(key).call()\n    return data\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  configHelperNetworks,\n  getFreOrderParams,\n  allowance,\n  ZERO_ADDRESS\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public GASLIMIT_DEFAULT = 1000000\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for mint method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .approve(spender, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasApprove(\n      dtAddress,\n      spender,\n      amount,\n      address,\n      dtContract\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createFixedRate(\n          fixedRateParams.fixedRateAddress,\n          [\n            fixedRateParams.baseTokenAddress,\n            address,\n            fixedRateParams.marketFeeCollector,\n            fixedRateParams.allowedConsumer\n          ],\n          [\n            fixedRateParams.baseTokenDecimals,\n            fixedRateParams.datatokenDecimals,\n            fixedRateParams.fixedRate,\n            fixedRateParams.marketFee,\n            withMint\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateFixedRate(\n      dtAddress,\n      address,\n      fixedRateParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createDispenser(\n          dispenserAddress,\n          dispenserParams.maxTokens,\n          dispenserParams.maxBalance,\n          dispenserParams.withMint,\n          dispenserParams.allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateDispenser(\n      dtAddress,\n      address,\n      dispenserAddress,\n      dispenserParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await this.estGasMint(\n        dtAddress,\n        address,\n        amount,\n        toAddress,\n        dtContract\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for addMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await this.estGasAddMinter(dtAddress, address, minter, dtContract)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    // Estimate gas for removeMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removeMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemoveMinter(dtAddress, address, minter, dtContract)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for addFeeManager method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addPaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasAddPaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removePaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemovePaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setPaymentCollector(paymentCollector)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager = (await this.getDTPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await this.estGasSetPaymentCollector(\n      dtAddress,\n      address,\n      paymentCollector,\n      dtContract\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .transfer(toAddress, amount)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasTransfer(\n        dtAddress,\n        toAddress,\n        amount,\n        address,\n        dtContract\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await this.estGasStartOrder(\n        dtAddress,\n        address,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const freContractParams = getFreOrderParams(freParams)\n\n      const estGas = await this.estGasBuyFromFreAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        freContractParams,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasBuyFromDispenserAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        dispenserContract,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setData(value)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasSetData(dtAddress, address, value, dtContract)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(value).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCleanPermissions(dtAddress, address, dtContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n        from: address\n      }),\n      this.config\n    )\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  configHelperNetworks,\n  setContractDefaults,\n  ZERO_ADDRESS\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .deployERC721Contract(\n          nftData.name,\n          nftData.symbol,\n          nftData.templateIndex,\n          ZERO_ADDRESS,\n          ZERO_ADDRESS,\n          nftData.tokenURI,\n          nftData.transferable,\n          nftData.owner\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await this.estGasCreateNFT(address, nftData)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        ZERO_ADDRESS,\n        ZERO_ADDRESS,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .add721TokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await this.estGasAddNFTTemplate(address, templateAddress)\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disable721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await this.estGasDisableNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivate721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await this.estGasReactivateNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .addTokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await this.estGasAddTokenTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disableTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await this.estGasDisableTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivateTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await this.estGasReactivateTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .startMultipleTokenOrder(orders)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await this.estGasStartMultipleTokenOrder(address, orders)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    // Get estimated gas value\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20(nftCreateData, ercCreateData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await this.estGasCreateNftWithErc20(address, nftCreateData, ercParams)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      const poolData = await getPoolCreationParams(this.web3, poolParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreateNftErc20WithPool(\n      address,\n      nftCreateData,\n      ercParams,\n      poolParams\n    )\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await this.estGasCreateNftErc20WithFixedRate(\n      address,\n      nftCreateData,\n      ercParams,\n      freParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n      LoggerInstance.error('Failed to estimate gas for createNftErc20WithDispenser', e)\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await this.estGasCreateNftErc20WithDispenser(\n      address,\n      nftCreateData,\n      ercParams,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n}\n\nexport default Config\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData } from '../utils'\nimport {\n  FileMetadata,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport fetch from 'cross-fetch'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url' }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute start failed: ', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n"],"names":["LogLevel","Logger","logLevel","Error","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","ZERO_ADDRESS","GASLIMIT_DEFAULT","amountToUnits","web3","token","amount","tokenContract","eth","Contract","methods","decimals","call","BigNumber","config","EXPONENTIAL_AT","times","exponentiatedBy","toString","e","message","unitsToAmount","amountFormatted","div","getPoolCreationParams","poolParams","ssContract","baseTokenAddress","baseTokenSender","publisherAddress","marketFeeCollector","poolTemplateAddress","vestedBlocks","Web3","utils","toWei","vestingAmount","baseTokenDecimals","rate","initialBaseTokenLiquidity","addresses","ssParams","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","getFairGasPrice","getGasPrice","x","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getErcCreationParams","ercParams","templateIndex","strings","minter","paymentCollector","mpFeeAddress","feeToken","uints","cap","feeAmount","bytess","getFreOrderParams","freParams","exchangeContract","exchangeId","maxBaseTokenAmount","swapMarketFee","marketFeeAddress","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","owner","datatokenDecimals","fixedRate","marketFee","postData","url","payload","postWithHeaders","headers","fetch","method","body","getData","downloadFile","index","response","ok","filename","get","match","split","pop","arrayBuffer","data","downloadFileBrowser","anchor","document","createElement","download","href","click","fetchData","opts","result","text","_error2","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","erc721FactoryAddress","ERC721Factory","sideStakingAddress","Staking","opfCommunityFeeCollector","OPFCommunityFeeCollector","poolTemplate","FixedPrice","Dispenser","Ocean","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","generateDid","erc721Address","toChecksumAddress","sha256","getHash","signHash","address","sign","signedMessage","r","substr","slice","s","v","balance","tokenAddress","account","balanceOf","trxReceipt","allowance","spender","approve","force","estApprove","estGas","_tokenContract$method3","send","from","gas","gasPrice","currentAllowence","Decimal","greaterThanOrEqualTo","contractInstance","gasLimitDefault","estimateGas","err","sleep","ms","Promise","resolve","setTimeout","getMaxRemoveLiquidity","poolInstance","poolAddress","getReserve","calcMaxExactIn","getMaxAddLiquidity","getMaxSwapExactIn","getMaxSwapExactOut","calcMaxExactOut","bind","pact","_settle","Aquarius","aquariusURL","did","signal","path","json","status","waitForAqua","txid","tries","_this4","ddo","event","validate","jsonResponse","valid","_this6","JSON","stringify","hash","proof","validatorAddress","publicKey","errors","MaxUint256","prototype","state","update","_isSettledPact","_resumeAfterBody","reject","_resumeAfterTest","Pool","poolAbi","PoolTemplate","abi","sharesBalance","_this2","fromWei","estSetSwapFee","fee","poolContract","defaultErc20Abi","setSwapFee","pool","_pool$methods$setSwap2","getNumTokens","_this8","getPoolSharesTotalSupply","_this10","totalSupply","getCurrentTokens","_this12","getFinalTokens","_this14","getController","_this16","getBaseToken","_this18","getBaseTokenAddress","getDatatoken","_this20","getDatatokenAddress","getMarketFee","_this22","getMarketFeeCollector","_this24","_publishMarketCollector","getOPCCollector","_this26","_opcCollector","isBound","_this28","_this30","getBalance","isFinalized","_this32","getSwapFee","_this34","getNormalizedWeight","_this36","weight","getDenormalizedWeight","_this38","getTotalDenormalizedWeight","_this40","getMarketFees","_this42","publishMarketFees","getCurrentMarketFees","_this44","getCurrentOPCFees","_this46","getCommunityFees","_this48","communityFees","estCollectOPC","_this50","collectOPC","_this52","_pool$methods$collect2","estCollectMarketFee","_this54","collectMarketFee","_this56","_this55$getMarketFeeC","_pool$methods$collect4","estUpdatePublishMarketFee","newPublishMarketAddress","newPublishMarketSwapFee","_this58","updatePublishMarketFee","_this60","_this59$getMarketFeeC","_pool$methods$updateP2","estSwapExactAmountIn","tokenInOutMarket","amountsInOutMaxFee","_this62","tokenIn","tokenAmountIn","tokenOut","minAmountOut","maxPrice","_amountsInOutMaxFee$m","swapExactAmountIn","_this64","maxSwap","greaterThan","_pool$methods$swapExa2","estSwapExactAmountOut","_this66","maxAmountIn","tokenAmountOut","swapExactAmountOut","_this68","_amountsInOutMaxFee$m4","_pool$methods$swapExa4","estJoinPool","poolAmountOut","maxAmountsIn","_this70","joinPool","_this72","weiMaxAmountsIn","tokens","_pool$methods$joinPoo2","i","push","estExitPool","poolAmountIn","minAmountsOut","_this74","exitPool","_this76","weiMinAmountsOut","_pool$methods$exitPoo2","estJoinswapExternAmountIn","minPoolAmountOut","_this78","joinswapExternAmountIn","_this80","amountInFormatted","_pool$methods$joinswa2","estExitswapPoolAmountIn","minTokenAmountOut","_this82","exitswapPoolAmountIn","_this84","calcSingleOutGivenPoolIn","minTokenOutFormatted","_pool$methods$exitswa2","getSpotPrice","decimalsDiff","decimalsTokenIn","decimalsTokenOut","price","_this86","tokenOutContract","tokenInContract","getAmountInExactOut","_this88","amountOutFormatted","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","tokenAmount","liquidityProviderSwapFeeAmount","getAmountOutExactIn","_this90","calcPoolOutGivenSingleIn","_this92","_pool$methods","calcPoolOutSingleIn","_calcPoolOutSingleIn","calcSingleInGivenPoolOut","_this94","calcSingleInPoolOut","_this96","_pool$methods2","calcSingleOutPoolIn","_calcSingleOutPoolIn","calcPoolInGivenSingleOut","_this98","_pool$methods3","calcPoolInSingleOut","_calcPoolInSingleOut","getSwapEventSignature","eventdata","o","encodeEventSignature","getJoinEventSignature","getExitEventSignature","FixedRateCreateProgressStep","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","maxTokens","maxBalance","_exit2","logger","estGasCreate","dtAddress","allowedSwapper","create","_this5$dispenserContr","estGasActivate","activate","_this9$dispenserContr","estGasDeactivate","deactivate","_this13$dispenserCont","estGasSetAllowedSwapper","newAllowedSwapper","setAllowedSwapper","_this17$dispenserCont","estGasDispense","destination","dispense","_this21$dispenserCont","estGasOwnerWithdraw","ownerWithdraw","_this25$dispenserCont","isDispensable","datatoken","active","String","isMinter","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","generateExchangeId","baseToken","estBuyDT","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","getExchange","exchange","consumeMarketFeeFormatted","dtAmountFormatted","maxBtFormatted","_this9$contract$metho","estSellDT","sellDT","minBaseTokenAmount","minBtFormatted","_this13$contract$meth","getNumberOfExchanges","estSetRate","newRate","_fixedRate$methods","setRate","_setRate","_this19$contract$meth","estSetAllowedSwapper","_this23$contract$meth","estActivate","toggleExchangeState","_this27$contract$meth","estDeactivate","_this31$contract$meth","getRate","weiRate","getDTSupply","dtSupply","_this35$getExchange","getBTSupply","btSupply","_this37$getExchange","getAllowedSwapper","calcBaseInGivenOutDT","fixedRateExchange","_this41$contract$meth","_calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","getAmountBTOut","_this43$contract$meth","calcBaseOutGivenInDT","_calcBaseOutGivenInDT","_this43$getExchange","dtDecimals","btDecimals","dtBalance","btBalance","getFeesInfo","opcFee","_this47$getExchange2","marketFeeAvailable","_this47$getExchange","oceanFeeAvailable","getExchanges","isActive","estActivateMint","toggleMintState","activateMint","_this55$contract$meth","estDeactivateMint","deactivateMint","_this59$contract$meth","estCollectBT","fixedrate","amountWei","collectBT","_this63$contract$meth","estCollectDT","collectDT","_this67$contract$meth","_this71$contract$meth","estCollectOceanFee","collectOceanFee","_this75$contract$meth","opcCollector","getRouter","router","getExchangeOwner","_this81$getExchange","exchangeOwner","estUpdateMarketFee","newMarketFee","updateMarketFee","_this85$contract$meth","estUpdateMarketFeeCollector","newMarketFeeCollector","updateMarketFeeCollector","_this89$contract$meth","SideStaking","SideStakingTemplate","parseInt","getDatatokenCirculatingSupply","ssAddress","sideStaking","getDatatokenCurrentCirculatingSupply","getPublisherAddress","getPoolAddress","getBaseTokenBalance","getDatatokenBalance","getvestingEndBlock","getvestingAmount","getvestingLastBlock","getvestingAmountSoFar","estGetVesting","getVesting","_sideStaking$methods$14","estSetPoolSwapFee","swapFee","setPoolSwapFee","_sideStaking$methods$17","Router","routerAddress","RouterAbi","defaultRouter","estGasBuyDTBatch","operations","buyDTBatch","_this3$router$methods","isApprovedToken","isSideStaking","isSSContract","isFixedPrice","isFixedRateContract","getOwner","routerOwner","getNFTFactory","factory","isPoolTemplate","estGasAddApprovedToken","routerContract","addApprovedToken","_this19$getOwner","_this19$router$method","estGasRemoveApprovedToken","removeApprovedToken","_this23$getOwner","_this23$router$method","estGasAddSSContract","addSSContract","_this27$getOwner","_this27$router$method","estGasRemoveSSContract","removeSSContract","_this31$getOwner","_this31$router$method","estGasAddFixedRateContract","addFixedRateContract","_this35$getOwner","_this35$router$method","estGasRemoveFixedRateContract","removeFixedRateContract","_this39$getOwner","_this39$router$method","estGasAddDispenserContract","addDispenserContract","_this43$getOwner","_this43$router$method","estGasRemoveDispenserContract","removeDispenserContract","_this47$getOwner","_this47$router$method","getOPCFee","getCurrentOPCFee","swapOceanFee","estGasUpdateOPCFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","_this55$getOwner","_this55$router$method","estGasAddPoolTemplate","templateAddress","addPoolTemplate","_this59$getOwner","_this59$router$method","estGasRemovePoolTemplate","removePoolTemplate","_this63$getOwner","_this63$router$method","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","estGasCreateErc20","nftAddress","nftContract","createERC20","createErc20","getNftPermissions","_this3$getNftPermissi","deployERC20","_nftContract$methods$2","events","TokenCreated","returnValues","estGasAddManager","manager","addManager","getNftOwner","_this7$getNftOwner","_nftContract$methods$4","estGasRemoveManager","removeManager","_this11$getNftOwner","_nftContract$methods$6","estGasAddErc20Deployer","erc20Deployer","addToCreateERC20List","addErc20Deployer","_this15$getNftPermiss","_nftContract$methods$8","estGasRemoveErc20Deployer","removeFromCreateErc20List","removeErc20Deployer","_temp11","_this19$getNftPermiss2","removeFromCreateERC20List","_nftContract$methods$10","_this19$getNftPermiss","estGasAddMetadataUpdater","metadataUpdater","addToMetadataList","addMetadataUpdater","_this23$getNftPermiss","_nftContract$methods$12","esGasRemoveMetadataUpdater","removeFromMetadataList","removeMetadataUpdater","_temp17","_this27$getNftPermiss2","updateMetadata","_nftContract$methods$14","_this27$getNftPermiss","estGasAddStoreUpdater","storeUpdater","addTo725StoreList","addStoreUpdater","_this31$getNftPermiss","_nftContract$methods$16","estGasRemoveStoreUpdater","removeFrom725StoreList","removeStoreUpdater","_temp23","_this35$getNftPermiss2","store","_nftContract$methods$18","_this35$getNftPermiss","estGasCleanPermissions","cleanPermissions","_this39$getNftOwner","_nftContract$methods$20","estGasTransferNft","nftOwner","nftReceiver","tokenId","transferFrom","transferNft","_this43$getNftOwner","tokenIdentifier","_nftContract$methods$22","estGasSafeTransferNft","safeTransferFrom","safeTransferNft","_this47$getNftOwner","_nftContract$methods$24","estGasSetMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","setMetadata","_this51$getNftPermiss","_nftContract$methods$26","estGasSetMetadataAndTokenURI","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataAndTokenURI","_this55$getNftPermiss","_nftContract$methods$28","estGasSetMetadataState","setMetaDataState","setMetadataState","_this59$getNftPermiss","_nftContract$methods$30","estSetTokenURI","setTokenURI","_nftContract$methods$32","ownerOf","getPermissions","getMetadata","getMetaData","isErc20Deployer","isERC20Deployer","key","getTokenURI","id","tokenURI","recover","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","estGasApprove","dtContract","_dtContract$methods$a2","estGasMint","toAddress","mint","estGasCreateFixedRate","fixedRateParams","createFixedRate","_dtContract$methods$c2","estGasCreateDispenser","dispenserParams","createDispenser","_dtContract$methods$c4","getDTPermissions","_this15$getDTPermissi","getCap","capAvailble","gte","_dtContract$methods$m2","estGasAddMinter","addMinter","_this19$isERC20Deploy","_dtContract$methods$a4","estGasRemoveMinter","removeMinter","_this23$isERC20Deploy","_dtContract$methods$r2","estGasAddPaymentManager","paymentManager","addPaymentManager","_this27$isERC20Deploy","_dtContract$methods$a6","estGasRemovePaymentManager","removePaymentManager","_this31$isERC20Deploy","_dtContract$methods$r4","estGasSetPaymentCollector","setPaymentCollector","nftPermissions","isPaymentManager","isNftOwner","_dtContract$methods$s2","_this35$nft$getNftOwn","_this35$getDTPermissi","getNFTAddress","getPaymentCollector","transfer","weiAmount","transferWei","estGasTransfer","_dtContract$methods$t2","estGasStartOrder","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","getPublishingMarketFee","publishMarketFee","_dtContract$methods$s4","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","getCurrentAllownceTokens","currentAllowance","all","estGasBuyFromFreAndOrder","orderParams","buyFromFreAndOrder","freContractParams","_dtContract$methods$b2","estGasBuyFromDispenserAndOrder","buyFromDispenserAndOrder","_dtContract$methods$b4","estGasSetData","value","setData","_dtContract$methods$s6","_this63$nft2","_this63$nft$getNftOwn","_dtContract$methods$c6","permissions","getDecimals","getERC721Address","NftFactory","factory721","defaultFactory721Abi","estGasCreateNFT","nftData","deployERC721Contract","transferable","createNFT","getCurrentNFTTemplateCount","_nftData$templateInde2","getNFTTemplate","_this3$getNFTTemplate","_this3$factory721$met","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTokenTemplateCount","getCurrentTemplateCount","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","estGasAddNFTTemplate","add721TokenTemplate","addNFTTemplate","_this25$getOwner","_this25$factory721$me","estGasDisableNFTTemplate","disable721TokenTemplate","disableNFTTemplate","_this29$getOwner","_this29$factory721$me","estGasReactivateNFTTemplate","reactivate721TokenTemplate","reactivateNFTTemplate","_this33$getOwner","_this33$factory721$me","estGasAddTokenTemplate","addTokenTemplate","_this37$getOwner","_this37$factory721$me","estGasDisableTokenTemplate","disableTokenTemplate","_this41$getOwner","_this41$getTokenTempl","_this41$factory721$me","estGasReactivateTokenTemplate","reactivateTokenTemplate","_this45$getOwner","_this45$getTokenTempl","_this45$factory721$me","estGasStartMultipleTokenOrder","orders","startMultipleTokenOrder","_this49$factory721$me","estGasCreateNftWithErc20","nftCreateData","ercCreateData","createNftWithErc20","_this53$factory721$me","estGasCreateNftErc20WithPool","poolData","createNftWithErc20WithPool","createNftErc20WithPool","_this57$factory721$me","estGasCreateNftErc20WithFixedRate","fixedData","createNftWithErc20WithFixedRate","createNftErc20WithFixedRate","_this61$factory721$me","estGasCreateNftErc20WithDispenser","createNftWithErc20WithDispenser","createNftErc20WithDispenser","_this65$factory721$me","Config","providerAddress","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","noZeroX","input","zeroOutput","regexp","conversorName","output","inputMatch","zeroXTransformer","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","signProviderRequest","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","encrypt","checkDidFiles","serviceId","args","files","results","checkFileUrl","getComputeEnvironments","_this10$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","algorithm","additionalDatasets","computeStartUrl","signatureMessage","documentId","Object","environment","statusText","params","computeStop","jobId","computeStopUrl","computeStatus","computeStatusUrl","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","isValidProvider","ProviderInstance"],"mappings":"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"}