import t from"web3";import e from"bignumber.js";import a from"cross-fetch";import s from"@oceanprotocol/contracts/addresses/address.json";import i from"crypto-js/sha256";import n from"decimal.js";import o from"@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json";import r from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json";import c from"@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json";import h from"@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json";import l from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json";import d from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json";import w from"@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json";var u;!function(t){t[t.None=-1]="None",t[t.Error=0]="Error",t[t.Warn=1]="Warn",t[t.Log=2]="Log",t[t.Verbose=3]="Verbose"}(u||(u={}));class m{constructor(t=u.Error){this.logLevel=void 0,this.logLevel=t}setLevel(t){this.logLevel=t}bypass(...t){this.dispatch("log",-Infinity,...t)}debug(...t){this.dispatch("debug",u.Verbose,...t)}log(...t){this.dispatch("log",u.Log,...t)}warn(...t){this.dispatch("warn",u.Warn,...t)}error(...t){this.dispatch("error",u.Error,...t)}dispatch(t,e,...a){this.logLevel>=e&&console[t](...a)}}const g=new m;var p={nouns:["Crab","Fish","Seal","Octopus","Shark","Seahorse","Walrus","Starfish","Whale","Orca","Penguin","Jellyfish","Squid","Lobster","Pelican","Shrimp","Oyster","Clam","Seagull","Dolphin","Shell","Cormorant","Otter","Anemone","Turtle","Coral","Ray","Barracuda","Krill","Anchovy","Angelfish","Barnacle","Clownfish","Cod","Cuttlefish","Eel","Fugu","Herring","Haddock","Ling","Mackerel","Manatee","Narwhal","Nautilus","Plankton","Porpoise","Prawn","Pufferfish","Swordfish","Tuna"],adjectives:["adamant","adroit","amatory","ambitious","amused","animistic","antic","arcadian","artistic","astonishing","astounding","baleful","bellicose","bilious","blissful","boorish","brave","breathtaking","brilliant","calamitous","caustic","cerulean","clever","charming","comely","competent","concomitant","confident","contumacious","corpulent","crapulous","creative","dazzling","dedicated","defamatory","delighted","delightful","determined","didactic","dilatory","dowdy","efficacious","effulgent","egregious","empowered","endemic","enthusiastic","equanimous","exceptional","execrable","fabulous","fantastic","fastidious","feckless","fecund","friable","fulsome","garrulous","generous","gentle","guileless","gustatory","heuristic","histrionic","hubristic","incendiary","incredible","insidious","insolent","inspired","intransigent","inveterate","invidious","invigorated","irksome","jejune","juicy","jocular","joyful","judicious","kind","lachrymose","limpid","loquacious","lovely","luminous","mannered","marvelous","mendacious","meretricious","minatory","mordant","motivated","munificent","nefarious","noxious","obtuse","optimistic","parsimonious","pendulous","pernicious","pervasive","petulant","passionate","phenomenal","platitudinous","pleasant","powerful","precipitate","propitious","puckish","querulous","quiescent","rebarbative","recalcitant","redolent","rhadamanthine","risible","ruminative","sagacious","salubrious","sartorial","sclerotic","serpentine","smart","spasmodic","strident","stunning","stupendous","taciturn","tactful","tasty","tenacious","tremendous","tremulous","trenchant","turbulent","turgid","ubiquitous","uxorious","verdant","vibrant","voluble","voracious","wheedling","withering","wonderful","zealous"]};function f(t){const e=t||p,a=Math.floor(Math.random()*e.adjectives.length),s=Math.floor(Math.random()*e.nouns.length),i=Math.floor(100*Math.random()),n=e.adjectives[a].replace(/^\w/,t=>t.toUpperCase()),o=e.nouns[s].replace(/^\w/,t=>t.toUpperCase());return{name:`${n} ${o} Token`,symbol:`${(n.substring(0,3)+o.substring(0,3)).toUpperCase()}-${i}`}}const y=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];function b(t,e){return e&&(e.transactionBlockTimeout&&(t.transactionBlockTimeout=e.transactionBlockTimeout),e.transactionConfirmationBlocks&&(t.transactionConfirmationBlocks=e.transactionConfirmationBlocks),e.transactionPollingTimeout&&(t.transactionPollingTimeout=e.transactionPollingTimeout)),console.log(`contract config ${null==e?void 0:e.transactionBlockTimeout} , ${null==e?void 0:e.transactionConfirmationBlocks} , ${null==e?void 0:e.transactionPollingTimeout}`),console.log(`contract value ${null==t?void 0:t.transactionBlockTimeout} , ${null==t?void 0:t.transactionConfirmationBlocks} , ${null==t?void 0:t.transactionPollingTimeout}`),t}async function A(t,a){const s=new e(await t.eth.getGasPrice());return console.log(`getFairGasPrice ${null==a?void 0:a.gasFeeMultiplier}`),a&&a.gasFeeMultiplier?s.multipliedBy(a.gasFeeMultiplier).integerValue(e.ROUND_DOWN).toString(10):s.toString(10)}function T(e){let a,s;return e.name&&e.symbol||({name:a,symbol:s}=f()),{templateIndex:e.templateIndex,strings:[e.name||a,e.symbol||s],addresses:[e.minter,e.paymentCollector,e.mpFeeAddress,e.feeToken],uints:[t.utils.toWei(e.cap),t.utils.toWei(e.feeAmount)],bytess:[]}}function E(e){return{exchangeContract:e.exchangeContract,exchangeId:e.exchangeId,maxBaseTokenAmount:t.utils.toWei(e.maxBaseTokenAmount),swapMarketFee:t.utils.toWei(e.swapMarketFee),marketFeeAddress:e.marketFeeAddress}}function C(e){e.allowedConsumer||(e.allowedConsumer="0x0000000000000000000000000000000000000000");const a=e.withMint?1:0;return{fixedPriceAddress:e.fixedRateAddress,addresses:[e.baseTokenAddress,e.owner,e.marketFeeCollector,e.allowedConsumer],uints:[e.baseTokenDecimals,e.datatokenDecimals,t.utils.toWei(e.fixedRate),t.utils.toWei(e.marketFee),a]}}async function k(e,a){return{addresses:[a.ssContract,a.baseTokenAddress,a.baseTokenSender,a.publisherAddress,a.marketFeeCollector,a.poolTemplateAddress],ssParams:[t.utils.toWei(a.rate),a.baseTokenDecimals,t.utils.toWei(a.vestingAmount),a.vestedBlocks,await v(e,a.baseTokenAddress,a.initialBaseTokenLiquidity)],swapFees:[t.utils.toWei(a.swapFeeLiquidityProvider),t.utils.toWei(a.swapFeeMarketRunner)]}}async function F(t,a,s){try{const i=new t.eth.Contract(y,a);let n=await i.methods.decimals().call();"0"===n&&(n=18);const o=new e(s).div(new e(10).exponentiatedBy(n));return e.config({EXPONENTIAL_AT:50}),o.toString()}catch(t){g.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${t.message}`)}}async function v(t,a,s){try{const i=new t.eth.Contract(y,a);let n=await i.methods.decimals().call();return"0"===n&&(n=18),e.config({EXPONENTIAL_AT:50}),new e(s).times(new e(10).exponentiatedBy(n)).toString()}catch(t){g.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${t.message}`)}}async function R(t,e){const s=await a(t,e);if(!s.ok)throw g.error(`Error requesting [${e.method}] ${t}`),g.error(`Response message: \n${await s.text()}`),s;return s}async function I(t){const e=document.createElement("a");e.download="",e.href=t,e.click()}async function S(t,e){const s=await a(t);if(!s.ok)throw new Error("Response error.");let i;try{i=s.headers.get("content-disposition").match(/attachment;filename=(.+)/)[1]}catch(a){try{i=t.split("/").pop()}catch(t){i=`file${e}`}}return{data:await s.arrayBuffer(),filename:i}}async function G(t){return a(t,{method:"GET",headers:{"Content-type":"application/json"}})}async function M(t,e){return async function(t,e,s){return a(t,null!=e?{method:"POST",body:e,headers:{"Content-type":"application/json"}}:{method:"POST"})}(t,e)}function P(){return P=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&(t[s]=a[s])}return t},P.apply(this,arguments)}const x={chainId:null,network:"unknown",metadataCacheUri:"https://v4.aquarius.oceanprotocol.com",nodeUri:"http://127.0.0.1:8545",providerUri:"http://127.0.0.1:8030",subgraphUri:null,explorerUri:null,oceanTokenAddress:null,oceanTokenSymbol:"OCEAN",poolTemplateAddress:null,fixedRateExchangeAddress:null,dispenserAddress:null,startBlock:0,transactionBlockTimeout:50,transactionConfirmationBlocks:1,transactionPollingTimeout:750,gasFeeMultiplier:1},O=[P({},x),P({},x,{chainId:8996,network:"development",metadataCacheUri:"http://127.0.0.1:5000"}),P({},x,{chainId:3,network:"ropsten",nodeUri:"https://ropsten.infura.io/v3",providerUri:"https://v4.provider.ropsten.oceanprotocol.com",subgraphUri:"https://v4.subgraph.ropsten.oceanprotocol.com",explorerUri:"https://ropsten.etherscan.io",gasFeeMultiplier:1.1}),P({},x,{chainId:4,network:"rinkeby",nodeUri:"https://rinkeby.infura.io/v3",providerUri:"https://v4.provider.rinkeby.oceanprotocol.com",subgraphUri:"https://v4.subgraph.rinkeby.oceanprotocol.com",explorerUri:"https://rinkeby.etherscan.io",gasFeeMultiplier:1.1}),P({},x,{chainId:1,network:"mainnet",nodeUri:"https://mainnet.infura.io/v3",providerUri:"https://v4.provider.mainnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mainnet.oceanprotocol.com",explorerUri:"https://etherscan.io",startBlock:11105459,transactionBlockTimeout:150,transactionConfirmationBlocks:5,transactionPollingTimeout:1750,gasFeeMultiplier:1.05}),P({},x,{chainId:137,network:"polygon",nodeUri:"https://polygon-mainnet.infura.io/v3",providerUri:"https://v4.provider.polygon.oceanprotocol.com",subgraphUri:"https://v4.subgraph.polygon.oceanprotocol.com",explorerUri:"https://polygonscan.com",oceanTokenSymbol:"mOCEAN"}),P({},x,{chainId:1287,network:"moonbase",nodeUri:"https://rpc.api.moonbase.moonbeam.network",providerUri:"https://v4.provider.moonbase.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonbase.oceanprotocol.com",explorerUri:"https://moonbase.moonscan.io/",gasFeeMultiplier:1.1}),P({},x,{chainId:2021e3,network:"gaiaxtestnet",nodeUri:"https://rpc.gaiaxtestnet.oceanprotocol.com",providerUri:"https://v4.provider.gaiaxtestnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.gaiaxtestnet.oceanprotocol.com",explorerUri:"https://blockscout.gaiaxtestnet.oceanprotocol.com"}),P({},x,{chainId:80001,network:"mumbai",nodeUri:"https://polygon-mumbai.infura.io/v3",providerUri:"https://v4.provider.mumbai.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mumbai.oceanprotocol.com",explorerUri:"https://mumbai.polygonscan.com",gasFeeMultiplier:1.1}),P({},x,{chainId:56,network:"bsc",nodeUri:"https://bsc-dataseed.binance.org",providerUri:"https://v4.provider.bsc.oceanprotocol.com",subgraphUri:"https://v4.subgraph.bsc.oceanprotocol.com",explorerUri:"https://bscscan.com/",gasFeeMultiplier:1.05}),P({},x,{chainId:246,network:"energyweb",nodeUri:"https://rpc.energyweb.org",providerUri:"https://v4.provider.energyweb.oceanprotocol.com",subgraphUri:"https://v4.subgraph.energyweb.oceanprotocol.com",explorerUri:"https://explorer.energyweb.org",gasFeeMultiplier:1.05}),P({},x,{chainId:1285,network:"moonriver",nodeUri:"https://moonriver.api.onfinality.io/public",providerUri:"https://v4.provider.moonriver.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonriver.oceanprotocol.com",explorerUri:"https://moonriver.moonscan.io/",gasFeeMultiplier:1.05})];class U{getAddressesFromEnv(t,e){let a;if(e)try{const{FixedPrice:s,Dispenser:i,Staking:n,poolTemplate:o,ERC721Factory:r,OPFCommunityFeeCollector:c,Ocean:h,chainId:l,startBlock:d}=e[t];a=P({erc721FactoryAddress:r,sideStakingAddress:n,opfCommunityFeeCollector:c,poolTemplateAddress:o,fixedRateExchangeAddress:s,dispenserAddress:i,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}catch(t){}else if(s[t]){const{FixedPrice:e,Dispenser:i,Staking:n,poolTemplate:o,OPFCommunityFeeCollector:r,ERC721Factory:c,Ocean:h,chainId:l,startBlock:d}=s[t];a=P({erc721FactoryAddress:c,sideStakingAddress:n,opfCommunityFeeCollector:r,poolTemplateAddress:o,fixedRateExchangeAddress:e,dispenserAddress:i,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}return a}getConfig(t,e){const a="string"==typeof t?"network":"chainId";let s=O.find(e=>e[a]===t);return s?(s=P({},s,this.getAddressesFromEnv(s.network)),P({},s,{nodeUri:e?`${s.nodeUri}/${e}`:s.nodeUri})):(g.error(`No config found for given network '${t}'`),null)}}function L(e,a){return e=t.utils.toChecksumAddress(e),`did:op:${i(e+a.toString(10)).toString()}`}function D(t){try{return i(t).toString()}catch(t){g.error("getHash error: ",t.message)}}const N="0x0000000000000000000000000000000000000000",$=1e6;async function W(t,e,a,s){const i=t&&t.currentProvider&&t.currentProvider.isMetaMask;try{return await t.eth.personal.sign(e,a,s)}catch(s){if(i)throw s;g.warn("Error on personal sign."),g.warn(s);try{return await t.eth.sign(e,a)}catch(t){throw g.error("Error on sign."),g.error(t),new Error("Error executing personal sign")}}}async function _(t,e,a){let s=await t.eth.sign(e,a);s=s.substr(2);const i="0x"+s.slice(0,64),n="0x"+s.slice(64,128);let o="0x"+s.slice(128,130);return"0x00"===o&&(o="0x1b"),"0x01"===o&&(o="0x1c"),{v:o,r:i,s:n}}async function B(t,e,a,s){const i=t.utils.utf8ToHex(e),n=t&&t.currentProvider&&t.currentProvider.isMetaMask;try{return await t.eth.personal.sign(i,a,s)}catch(e){if(n)throw e;g.warn("Error on personal sign."),g.warn(e);try{return await t.eth.sign(i,a)}catch(t){throw g.error("Error on sign."),g.error(t),new Error("Error executing personal sign")}}}async function j(t,e,a,s,i,n){const o=n||new t.eth.Contract(y,a),r=1e6;let c;try{c=await o.methods.approve(s,i).estimateGas({from:e},(t,e)=>t?r:e)}catch(t){c=r,g.error("estimate gas failed for approve!",t)}return c}async function q(t,e,a,s,i,o=!1){const r=new t.eth.Contract(y,a);if(!o){const o=await z(t,a,e,s);if(new n(o).greaterThanOrEqualTo(new n(i)))return o}let c=null;const h=await v(t,a,i),l=await j(t,e,a,s,h,r);try{c=await r.methods.approve(s,h).send({from:e,gas:l+1,gasPrice:await A(t,null)})}catch(t){g.error(`ERRPR: Failed to approve spender to spend tokens : ${t.message}`)}return c}async function z(t,e,a,s){const i=new t.eth.Contract(y,e),n=await i.methods.allowance(a,s).call();return await F(t,e,n)}async function J(t,e,a){const s=new t.eth.Contract(y,e),i=await s.methods.balanceOf(a).call();return await F(t,e,i)}async function H(t){return new Promise(e=>{setTimeout(e,t)})}function Z(t){return new n(t).div(3.01)}function V(t){return new n(t).div(2.01)}async function X(t,e,a){return Z(await t.getReserve(e,a))}async function Q(t,e,a){return V(await t.getReserve(e,a))}async function K(t,e,a){return V(await t.getReserve(e,a))}async function Y(t,e,a){return V(await t.getReserve(e,a))}class tt{constructor(t){this.aquariusURL=void 0,this.aquariusURL=t}async resolve(t,e){const s=this.aquariusURL+"/api/aquarius/assets/ddo/"+t;try{const t=await a(s,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(t.ok)return await t.json();throw new Error("HTTP request failed with status "+t.status)}catch(t){throw g.error(t),new Error("HTTP request failed")}}async waitForAqua(t,e,s){let i=0;do{try{const i=this.aquariusURL+"/api/aquarius/assets/ddo/"+t,n=await a(i,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});if(n.ok){const t=await n.json();if(!e)return t;if(t.event&&t.event.txid===e)return t}}catch(t){}await H(1500),i++}while(i<100);return null}async validate(t,e){const s={valid:!1};let i;try{const n=this.aquariusURL+"/api/aquarius/assets/ddo/validate",o=await a(n,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:e});i=await o.json(),200===o.status?(s.valid=!0,s.hash=i.hash,s.proof={validatorAddress:i.publicKey,r:i.r[0],s:i.s[0],v:i.v}):(s.errors=i,g.error("validate Metadata failed:",o.status,s.errors))}catch(t){g.error("Error validating metadata: ",t)}return s}}const et="115792089237316195423570985008687907853269984665640564039457584007913129639934";class at{constructor(t,e=null,a){this.poolAbi=void 0,this.web3=void 0,this.GASLIMIT_DEFAULT=1e6,this.config=void 0,this.poolAbi=e||o.abi,this.web3=t,this.config=a||O[0]}async sharesBalance(t,e){let a=null;try{const s=b(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=await s.methods.balanceOf(t).call();a=this.web3.utils.fromWei(i)}catch(t){g.error(`ERROR: Failed to get shares of pool : ${t.message}`)}return a}async estSetSwapFee(t,e,a,s){const i=s||b(new this.web3.eth.Contract(r.abi,e),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setSwapFee(a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setSwapFee(t,e,a){const s=b(new this.web3.eth.Contract(this.poolAbi,e,{from:t}),this.config);let i=null;const n=await this.estSetSwapFee(t,e,a);try{i=await s.methods.setSwapFee(this.web3.utils.toWei(a)).send({from:t,gas:n,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to set pool swap fee: ${t.message}`)}return i}async getNumTokens(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getNumTokens().call()}catch(t){g.error(`ERROR: Failed to get number of tokens: ${t.message}`)}return a}async getPoolSharesTotalSupply(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.totalSupply().call();a=this.web3.utils.fromWei(t)}catch(t){g.error(`ERROR: Failed to get total supply of pool shares: ${t.message}`)}return a}async getCurrentTokens(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getCurrentTokens().call()}catch(t){g.error(`ERROR: Failed to get tokens composing this pool: ${t.message}`)}return a}async getFinalTokens(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getFinalTokens().call()}catch(t){g.error(`ERROR: Failed to get the final tokens composing this pool ${t.message}`)}return a}async getController(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getController().call()}catch(t){g.error(`ERROR: Failed to get pool controller address: ${t.message}`)}return a}async getBaseToken(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getBaseTokenAddress().call()}catch(t){g.error(`ERROR: Failed to get baseToken address: ${t.message}`)}return a}async getDatatoken(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getDatatokenAddress().call()}catch(t){g.error(`ERROR: Failed to get datatoken address: ${t.message}`)}return a}async getMarketFee(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getMarketFee().call()}catch(t){g.error(`ERROR: Failed to get getMarketFee: ${t.message}`)}return this.web3.utils.fromWei(a).toString()}async getMarketFeeCollector(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods._publishMarketCollector().call()}catch(t){g.error(`ERROR: Failed to get marketFeeCollector address: ${t.message}`)}return a}async getOPCCollector(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods._opcCollector().call()}catch(t){g.error(`ERROR: Failed to get OPF Collector address: ${t.message}`)}return a}async isBound(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{s=await a.methods.isBound(e).call()}catch(t){g.error(`ERROR: Failed to check whether a token       bounded to a pool. ${t.message}`)}return s}async getReserve(t,e){let a=null;try{const s=b(new this.web3.eth.Contract(this.poolAbi,t),this.config),i=await s.methods.getBalance(e).call();a=await F(this.web3,e,i)}catch(t){g.error(`ERROR: Failed to get how many tokens       are in the pool: ${t.message}`)}return a.toString()}async isFinalized(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.isFinalized().call()}catch(t){g.error(`ERROR: Failed to check whether pool is finalized: ${t.message}`)}return a}async getSwapFee(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getSwapFee().call();a=this.web3.utils.fromWei(t)}catch(t){g.error(`ERROR: Failed to get pool fee: ${t.message}`)}return a}async getNormalizedWeight(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getNormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){g.error(`ERROR: Failed to get normalized weight of a token: ${t.message}`)}return s}async getDenormalizedWeight(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getDenormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){g.error(`ERROR: Failed to get denormalized weight of a token in pool ${t.message}`)}return s}async getTotalDenormalizedWeight(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getTotalDenormalizedWeight().call();a=this.web3.utils.fromWei(t)}catch(t){g.error(`ERROR: Failed to get total denormalized weight in pool ${t.message}`)}return a}async getMarketFees(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.publishMarketFees(e).call();s=await F(this.web3,e,t)}catch(t){g.error(`ERROR: Failed to get market fees for a token: ${t.message}`)}return s}async getCurrentMarketFees(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){g.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCurrentOPCFees(t){const e=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){g.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCommunityFees(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.communityFees(e).call();s=await F(this.web3,e,t)}catch(t){g.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}return s}async estCollectOPC(t,e,a){const s=a||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectOPC().estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectOPC(t,e){const a=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const i=await this.estCollectOPC(t,e);try{s=await a.methods.collectOPC().send({from:t,gas:i+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estCollectMarketFee(t,e,a){const s=a||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee().estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectMarketFee(t,e){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const a=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const i=await this.estCollectMarketFee(t,e);try{s=await a.methods.collectMarketFee().send({from:t,gas:i+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estUpdatePublishMarketFee(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.updatePublishMarketFee(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async updatePublishMarketFee(t,e,a,s){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let n=null;const o=await this.estUpdatePublishMarketFee(t,e,a,this.web3.utils.toWei(s));try{n=await i.methods.updatePublishMarketFee(a,this.web3.utils.toWei(s)).send({from:t,gas:o+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to updatePublishMarketFee : ${t.message}`)}return n}async estSwapExactAmountIn(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await v(this.web3,a.tokenIn,s.tokenAmountIn),r=await v(this.web3,a.tokenOut,s.minAmountOut),c=s.maxPrice?v(this.web3,await this.getBaseToken(e),s.maxPrice):et,h=this.GASLIMIT_DEFAULT;let l;try{l=await n.methods.swapExactAmountIn([a.tokenIn,a.tokenOut,a.marketFeeAddress],[o,r,c,this.web3.utils.toWei(s.swapMarketFee)]).estimateGas({from:t},(t,e)=>t?h:e)}catch(t){l=h}return l}async swapExactAmountIn(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await Q(this,e,a.tokenIn);if(new n(s.tokenAmountIn).greaterThan(o))throw new Error(`tokenAmountIn is greater than ${o.toString()}`);const r=await this.estSwapExactAmountIn(t,e,a,s),c=await v(this.web3,a.tokenIn,s.tokenAmountIn),h=await v(this.web3,a.tokenOut,s.minAmountOut);let l=null;const d=s.maxPrice?await v(this.web3,await this.getBaseToken(e),s.maxPrice):et;try{l=await i.methods.swapExactAmountIn([a.tokenIn,a.tokenOut,a.marketFeeAddress],[c,h,d,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:r+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return l}async estSwapExactAmountOut(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT,r=await v(this.web3,a.tokenIn,s.maxAmountIn),c=await v(this.web3,a.tokenOut,s.tokenAmountOut),h=s.maxPrice?await v(this.web3,await this.getBaseToken(e),s.maxPrice):et;let l;try{l=await n.methods.swapExactAmountOut([a.tokenIn,a.tokenOut,a.marketFeeAddress],[r,c,h,this.web3.utils.toWei(s.swapMarketFee)]).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){l=o}return l}async swapExactAmountOut(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await X(this,e,a.tokenIn);if(new n(s.tokenAmountOut).greaterThan(r))throw new Error(`tokenAmountOut is greater than ${r.toString()}`);const c=await this.estSwapExactAmountOut(t,e,a,s),h=await v(this.web3,a.tokenIn,s.maxAmountIn),l=await v(this.web3,a.tokenOut,s.tokenAmountOut),d=s.maxPrice?v(this.web3,await this.getBaseToken(e),s.maxPrice):et;try{o=await i.methods.swapExactAmountOut([a.tokenIn,a.tokenOut,a.marketFeeAddress],[h,l,d,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:c+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to swap exact amount out: ${t.message}`)}return o}async estJoinPool(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.joinPool(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async joinPool(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config),n=[],o=await this.getFinalTokens(e);for(let t=0;t<2;t++){const e=await v(this.web3,o[t],s[t]);n.push(e)}let r=null;const c=await this.estJoinPool(t,e,this.web3.utils.toWei(a),n);try{r=await i.methods.joinPool(this.web3.utils.toWei(a),n).send({from:t,gas:c+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to join pool: ${t.message}`)}return r}async estExitPool(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.exitPool(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async exitPool(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config),n=[],o=await this.getFinalTokens(e);for(let t=0;t<2;t++){const e=await v(this.web3,o[t],s[t]);n.push(e)}let r=null;const c=await this.estExitPool(t,e,this.web3.utils.toWei(a),n);try{r=await i.methods.exitPool(this.web3.utils.toWei(a),n).send({from:t,gas:c,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to exit pool: ${t.message}`)}return r}async estJoinswapExternAmountIn(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.joinswapExternAmountIn(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async joinswapExternAmountIn(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await this.getBaseToken(e),c=await K(this,e,r);if(new n(a).greaterThan(c))throw new Error(`tokenAmountOut is greater than ${c.toString()}`);const h=await v(this.web3,r,a),l=await this.estJoinswapExternAmountIn(t,e,h,this.web3.utils.toWei(s));try{o=await i.methods.joinswapExternAmountIn(h,this.web3.utils.toWei(s)).send({from:t,gas:l+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to pay tokens in order to       join the pool: ${t.message}`)}return o}async estExitswapPoolAmountIn(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.exitswapPoolAmountIn(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async exitswapPoolAmountIn(t,e,a,s){const i=b(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await this.getBaseToken(e),c=await this.calcSingleOutGivenPoolIn(e,r,a),h=await Y(this,e,r);if(new n(c).greaterThan(h))throw new Error(`tokenAmountOut is greater than ${h.toString()}`);const l=await v(this.web3,await this.getBaseToken(e),s),d=await this.estExitswapPoolAmountIn(t,e,this.web3.utils.toWei(a),l);try{o=await i.methods.exitswapPoolAmountIn(this.web3.utils.toWei(a),l).send({from:t,gas:d+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to pay pool shares into the pool: ${t.message}`)}return o}async getSpotPrice(t,a,s,i){const n=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=18,c=18;const h=b(new this.web3.eth.Contract(r.abi,a),this.config),l=b(new this.web3.eth.Contract(r.abi,s),this.config);try{o=await h.methods.decimals().call()}catch(t){g.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}try{c=await l.methods.decimals().call()}catch(t){g.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}let d,w=null;try{w=await n.methods.getSpotPrice(a,s,this.web3.utils.toWei(i)).call(),w=new e(w.toString())}catch(t){g.error("ERROR: Failed to get spot price of swapping tokenIn to tokenOut")}return o>c?(d=o-c,w=new e(w/10**d),w/=10**c):(d=c-o,w=new e(w*10**(2*d)),w/=10**c),w.toString()}async getAmountInExactOut(t,e,a,s,i){const o=b(new this.web3.eth.Contract(this.poolAbi,t),this.config),r=await X(this,t,e);if(new n(s).greaterThan(r))throw new Error(`tokenAmountOut is greater than ${r.toString()}`);const c=await v(this.web3,a,s);let h=null;try{const t=await o.methods.getAmountInExactOut(e,a,c,this.web3.utils.toWei(i)).call();h={tokenAmount:await F(this.web3,a,t.tokenAmountIn),liquidityProviderSwapFeeAmount:await F(this.web3,e,t.lpFeeAmount),oceanFeeAmount:await F(this.web3,e,t.oceanFeeAmount),publishMarketSwapFeeAmount:await F(this.web3,e,t.publishMarketSwapFeeAmount),consumeMarketSwapFeeAmount:await F(this.web3,e,t.consumeMarketSwapFeeAmount)}}catch(t){g.error(`ERROR: Failed to calcInGivenOut ${t.message}`)}return h}async getAmountOutExactIn(t,e,a,s,i){const o=b(new this.web3.eth.Contract(this.poolAbi,t),this.config),r=await Q(this,t,e);if(new n(s).greaterThan(r))throw new Error(`tokenAmountIn is greater than ${r.toString()}`);const c=await v(this.web3,e,s);let h=null;try{const t=await o.methods.getAmountOutExactIn(e,a,c,this.web3.utils.toWei(i)).call();h={tokenAmount:await F(this.web3,a,t.tokenAmountOut),liquidityProviderSwapFeeAmount:await F(this.web3,e,t.lpFeeAmount),oceanFeeAmount:await F(this.web3,e,t.oceanFeeAmount),publishMarketSwapFeeAmount:await F(this.web3,e,t.publishMarketSwapFeeAmount),consumeMarketSwapFeeAmount:await F(this.web3,e,t.consumeMarketSwapFeeAmount)}}catch(t){g.error(`ERROR: Failed to calcOutGivenIn ${t.message}`)}return h}async calcPoolOutGivenSingleIn(t,e,a){const s=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcPoolOutSingleIn(e,await v(this.web3,e,a)).call();i=await F(this.web3,t,n)}catch(t){g.error(`ERROR: Failed to calculate PoolOutGivenSingleIn : ${t.message}`)}return i}async calcSingleInGivenPoolOut(t,e,a){const s=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;const n=await v(this.web3,t,a);try{const t=await s.methods.calcSingleInPoolOut(e,n).call();i=await F(this.web3,e,t)}catch(t){g.error(`ERROR: Failed to calculate SingleInGivenPoolOut : ${t.message}`)}return i}async calcSingleOutGivenPoolIn(t,e,a){const s=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcSingleOutPoolIn(e,await v(this.web3,t,a)).call();i=await F(this.web3,e,n)}catch(t){g.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${t}`)}return i}async calcPoolInGivenSingleOut(t,e,a){const s=b(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcPoolInSingleOut(e,await v(this.web3,e,a)).call();i=await F(this.web3,t,n)}catch(t){g.error(`ERROR: Failed to calculate PoolInGivenSingleOut : ${t.message}`)}return i}getSwapEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_SWAP"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getJoinEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_JOIN"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getExitEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_EXIT"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}}class st{constructor(t,e=null,a=null,s){this.GASLIMIT_DEFAULT=1e6,this.web3=null,this.dispenserAddress=void 0,this.config=void 0,this.dispenserAbi=void 0,this.dispenserContract=void 0,this.web3=t,this.dispenserAddress=e,this.dispenserAbi=a||c.abi,this.config=s||O[0],t&&(this.dispenserContract=b(new this.web3.eth.Contract(this.dispenserAbi,this.dispenserAddress),this.config))}async status(t){try{const e=await this.dispenserContract.methods.status(t).call();return e.maxTokens=this.web3.utils.fromWei(e.maxTokens),e.maxBalance=this.web3.utils.fromWei(e.maxBalance),e.balance=this.web3.utils.fromWei(e.balance),e}catch(e){g.warn(`No dispenser available for datatoken: ${t}`)}return null}async estGasCreate(t,e,a,s,i){const n=this.GASLIMIT_DEFAULT;let o;try{o=await this.dispenserContract.methods.create(t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,i).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async create(t,e,a,s,i){const n=await this.estGasCreate(t,e,a,s,i);return await this.dispenserContract.methods.create(t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,i).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}async estGasActivate(t,e,a,s){let i;const n=this.GASLIMIT_DEFAULT;try{i=await this.dispenserContract.methods.activate(t,this.web3.utils.toWei(e),this.web3.utils.toWei(a)).estimateGas({from:s},(t,e)=>t?n:e)}catch(t){i=n}return i}async activate(t,e,a,s){try{const i=await this.estGasActivate(t,e,a,s);return await this.dispenserContract.methods.activate(t,this.web3.utils.toWei(e),this.web3.utils.toWei(a)).send({from:s,gas:i+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDeactivate(t,e){let a;const s=this.GASLIMIT_DEFAULT;try{a=await this.dispenserContract.methods.deactivate(t).estimateGas({from:e},(t,e)=>t?s:e)}catch(t){a=s}return a}async deactivate(t,e){try{const a=await this.estGasDeactivate(t,e);return await this.dispenserContract.methods.deactivate(t).send({from:e,gas:a+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasSetAllowedSwapper(t,e,a){let s;const i=this.GASLIMIT_DEFAULT;try{s=await this.dispenserContract.methods.setAllowedSwapper(t,a).estimateGas({from:e},(t,e)=>t?i:e)}catch(t){s=i}return s}async setAllowedSwapper(t,e,a){try{const s=await this.estGasSetAllowedSwapper(t,e,a);return await this.dispenserContract.methods.setAllowedSwapper(t,a).send({from:e,gas:s+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDispense(t,e,a="1",s){let i;const n=this.GASLIMIT_DEFAULT;try{i=await this.dispenserContract.methods.dispense(t,this.web3.utils.toWei(a),s).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){i=n}return i}async dispense(t,e,a="1",s){const i=await this.estGasDispense(t,e,a,s);try{return await this.dispenserContract.methods.dispense(t,this.web3.utils.toWei(a),s).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to dispense tokens: ${t.message}`)}return null}async estGasOwnerWithdraw(t,e){let a;const s=this.GASLIMIT_DEFAULT;try{a=await this.dispenserContract.methods.ownerWithdraw(t).estimateGas({from:e},(t,e)=>t?s:e)}catch(t){a=s}return a}async ownerWithdraw(t,e){const a=await this.estGasOwnerWithdraw(t,e);try{return await this.dispenserContract.methods.ownerWithdraw(t).send({from:e,gas:a+1,gasPrice:await A(this.web3,this.config)})}catch(t){g.error(`ERROR: Failed to withdraw tokens: ${t.message}`)}return null}async isDispensable(t,e,a,s="1"){const i=await this.status(t);return!(!i||!1===i.active||new n(await e.balance(t,a)).greaterThanOrEqualTo(i.maxBalance)||new n(String(s)).greaterThan(i.maxTokens)||!new n(i.balance).greaterThanOrEqualTo(s)&&!0!==i.isMinter)}}var it;!function(t){t[t.CreatingExchange=0]="CreatingExchange",t[t.ApprovingDatatoken=1]="ApprovingDatatoken"}(it||(it={}));class nt{constructor(t,e,a=null,s=null,i){this.GASLIMIT_DEFAULT=1e6,this.oceanAddress=null,this.fixedRateAddress=void 0,this.fixedRateExchangeAbi=void 0,this.fixedRateContract=void 0,this.web3=void 0,this.contract=null,this.config=void 0,this.ssAbi=void 0,this.web3=t,this.config=i||O[0],this.fixedRateExchangeAbi=a||h.abi,this.oceanAddress=s,this.fixedRateAddress=e,console.log("contract FRE config "),console.log(this.config),this.contract=b(new this.web3.eth.Contract(this.fixedRateExchangeAbi,this.fixedRateAddress),this.config)}async amountToUnits(t,e){return v(this.web3,t,e)}async unitsToAmount(t,e){return F(this.web3,t,e)}async generateExchangeId(t,e){return await this.contract.methods.generateExchangeId(t,e).call()}async estBuyDT(t,e,a,s,i,n,o){const r=o||this.fixedRateContract,c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.buyDT(e,a,s,i,n).estimateGas({from:t},(t,e)=>t?c:e)}catch(t){h=c}return h}async buyDT(t,e,a,s,i="0x0000000000000000000000000000000000000000",n="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(n),c=await this.amountToUnits(o.datatoken,a),h=await this.amountToUnits(o.baseToken,s),l=await this.estBuyDT(t,e,c,h,i,r);try{return await this.contract.methods.buyDT(e,c,h,i,r).send({from:t,gas:l+1,gasPrice:await A(this.web3,this.config)})}catch(t){return g.error(`ERROR: Failed to buy datatokens: ${t.message}`),null}}async estSellDT(t,e,a,s,i,n,o){const r=o||this.fixedRateContract,c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.sellDT(e,a,s,i,n).estimateGas({from:t},(t,e)=>t?c:e)}catch(t){h=c}return h}async sellDT(t,e,a,s,i="0x0000000000000000000000000000000000000000",n="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(n),c=await this.amountToUnits(o.datatoken,a),h=await this.amountToUnits(o.baseToken,s),l=await this.estBuyDT(t,e,c,h,i,r);try{return await this.contract.methods.sellDT(e,c,h,i,r).send({from:t,gas:l+1,gasPrice:await A(this.web3,this.config)})}catch(t){return g.error(`ERROR: Failed to sell datatokens: ${t.message}`),null}}async getNumberOfExchanges(){return await this.contract.methods.getNumberOfExchanges().call()}async estSetRate(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setRate(e,await this.web3.utils.toWei(a)).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setRate(t,e,a){const s=await this.estSetRate(t,e,a);return await this.contract.methods.setRate(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estSetAllowedSwapper(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setRate(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setAllowedSwapper(t,e,a){const s=await this.estSetAllowedSwapper(t,e,a);return await this.contract.methods.setAllowedSwapper(e,a).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estActivate(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleExchangeState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async activate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.active)return null;const s=await this.estActivate(t,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estDeactivate(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleExchangeState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async deactivate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.active)return null;const s=await this.estDeactivate(t,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async getRate(t){const e=await this.contract.methods.getRate(t).call();return await this.web3.utils.fromWei(e)}async getDTSupply(t){const e=await this.contract.methods.getDTSupply(t).call();return await this.unitsToAmount((await this.getExchange(t)).datatoken,e)}async getBTSupply(t){const e=await this.contract.methods.getBTSupply(t).call();return await this.unitsToAmount((await this.getExchange(t)).baseToken,e)}async getAllowedSwapper(t){return await this.contract.methods.getAllowedSwapper(t).call()}async calcBaseInGivenOutDT(t,e,a="0"){var s,i,n,o,r,c;const h=await this.getExchange(t);console.log(`contract calcBaseInGivenOutDT config ${null==(s=this.contract)?void 0:s.transactionBlockTimeout} , ${null==(i=this.contract)?void 0:i.transactionConfirmationBlocks} , ${null==(n=this.contract)?void 0:n.transactionPollingTimeout}`),g.log(`contract calcBaseInGivenOutDT config log : ${null==(o=this.contract)?void 0:o.transactionBlockTimeout} , ${null==(r=this.contract)?void 0:r.transactionConfirmationBlocks} , ${null==(c=this.contract)?void 0:c.transactionPollingTimeout}`);const l=await this.contract.methods.calcBaseInGivenOutDT(t,await this.amountToUnits(h.datatoken,e),this.web3.utils.toWei(a)).call();return{baseTokenAmount:await this.unitsToAmount(h.baseToken,l.baseTokenAmount),marketFeeAmount:await this.unitsToAmount(h.baseToken,l.marketFeeAmount),oceanFeeAmount:await this.unitsToAmount(h.baseToken,l.oceanFeeAmount),consumeMarketFeeAmount:await this.unitsToAmount(h.baseToken,l.consumeMarketFeeAmount)}}async getAmountBTOut(t,e,a="0"){const s=await this.getExchange(t),i=await this.contract.methods.calcBaseOutGivenInDT(t,await this.amountToUnits(s.datatoken,e),this.web3.utils.toWei(a)).call();return await this.unitsToAmount((await this.getExchange(t)).baseToken,i[0])}async getExchange(t){const e=await this.contract.methods.getExchange(t).call();return e.dtDecimals=e.dtDecimals.toString(),e.btDecimals=e.btDecimals.toString(),e.dtBalance=await this.unitsToAmount(e.datatoken,e.dtBalance),e.btBalance=await this.unitsToAmount(e.baseToken,e.btBalance),e.dtSupply=await this.unitsToAmount(e.datatoken,e.dtSupply),e.btSupply=await this.unitsToAmount(e.baseToken,e.btSupply),e.fixedRate=this.web3.utils.fromWei(e.fixedRate),e.exchangeId=t,e}async getFeesInfo(t){const e=await this.contract.methods.getFeesInfo(t).call();return e.opcFee=this.web3.utils.fromWei(e.opcFee.toString()),e.marketFee=this.web3.utils.fromWei(e.marketFee.toString()),e.marketFeeAvailable=await this.unitsToAmount((await this.getExchange(t)).baseToken,e.marketFeeAvailable),e.oceanFeeAvailable=await this.unitsToAmount((await this.getExchange(t)).baseToken,e.oceanFeeAvailable),e.exchangeId=t,e}async getExchanges(){return await this.contract.methods.getExchanges().call()}async isActive(t){return await this.contract.methods.isActive(t).call()}async estActivateMint(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleMintState(e,!0).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async activateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.withMint)return null;const s=await this.estActivateMint(t,e);return await this.contract.methods.toggleMintState(e,!0).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estDeactivateMint(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleMintState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async deactivateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.withMint)return null;const s=await this.estDeactivate(t,e);return await this.contract.methods.toggleMintState(e,!1).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estCollectBT(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;const r=await this.contract.methods.getExchange(e).call(),c=await this.amountToUnits(r.baseToken,a);try{o=await i.methods.collectBT(e,c).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async collectBT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.estCollectBT(t,e,a),i=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(i.baseToken,a);return await this.contract.methods.collectBT(e,n).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estCollectDT(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;const r=await this.contract.methods.getExchange(e).call(),c=await this.amountToUnits(r.datatoken,a);try{o=await i.methods.collectDT(e,c).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async collectDT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.estCollectDT(t,e,a),i=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(i.datatoken,a);return await this.contract.methods.collectDT(e,n).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estCollectMarketFee(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectMarketFee(t,e){if(!await this.getExchange(e))return null;const a=await this.estCollectMarketFee(t,e);return await this.contract.methods.collectMarketFee(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estCollectOceanFee(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectOceanFee(t,e){if(!await this.getExchange(e))return null;const a=await this.estCollectOceanFee(t,e);return await this.contract.methods.collectOceanFee(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async getOPCCollector(){let t=null;try{t=await this.contract.methods.opcCollector().call()}catch(t){g.error(`ERROR: Failed to get OPC Collector address: ${t.message}`)}return t}async getRouter(){let t=null;try{t=await this.contract.methods.router().call()}catch(t){g.error(`ERROR: Failed to get Router address: ${t.message}`)}return t}async getExchangeOwner(t){let e=null;try{e=await(await this.getExchange(t)).exchangeOwner}catch(t){g.error(`ERROR: Failed to get OPF Collector address: ${t.message}`)}return e}async estUpdateMarketFee(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.updateMarketFee(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async updateMarketFee(t,e,a){const s=await this.estSetRate(t,e,this.web3.utils.toWei(a));return await this.contract.methods.updateMarketFee(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estUpdateMarketFeeCollector(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.updateMarketFeeCollector(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async updateMarketFeeCollector(t,e,a){const s=await this.estUpdateMarketFeeCollector(t,e,a);return await this.contract.methods.updateMarketFeeCollector(e,a).send({from:t,gas:s+1,gasPrice:await A(this.web3,this.config)})}}class ot{constructor(t,e,a){this.GASLIMIT_DEFAULT=1e6,this.factory721Address=void 0,this.factory721Abi=void 0,this.nftAbi=void 0,this.web3=void 0,this.startBlock=void 0,this.config=void 0,this.nftAbi=e||d.abi,this.web3=t,this.config=a||O[0]}async estGasCreateErc20(t,e,a,s,i,n,o,r,c,h,l,d){const w=d||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),u=this.GASLIMIT_DEFAULT;let m;try{m=await w.methods.createERC20(l,[c,h],[a,s,i,n],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]).estimateGas({from:e},(t,e)=>t?u:e)}catch(t){m=u}return m}async createErc20(t,e,a,s,i,n,o,r,c,h,l){if(!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not ERC20Deployer");l||(l=1),c&&h||({name:c,symbol:h}=f());const d=b(new this.web3.eth.Contract(this.nftAbi,t),this.config),w=await this.estGasCreateErc20(t,e,a,s,i,n,o,r,c,h,l,d),u=await d.methods.createERC20(l,[c,h],[a,s,i,n],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]).send({from:e,gas:w+1,gasPrice:await A(this.web3,this.config)});let m=null;try{m=u.events.TokenCreated.returnValues[0]}catch(t){g.error(`ERROR: Failed to create datatoken : ${t.message}`)}return m}async estGasAddManager(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addManager(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=await this.estGasAddManager(t,e,a,s);return await s.methods.addManager(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasRemoveManager(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeManager(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=await this.estGasRemoveManager(t,e,a,s);return await s.methods.removeManager(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasAddErc20Deployer(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addToCreateERC20List(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addErc20Deployer(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddErc20Deployer(t,e,a,s);return await s.methods.addToCreateERC20List(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasRemoveErc20Deployer(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFromCreateErc20List(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeErc20Deployer(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e===a&&!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not Manager nor ERC20Deployer");const i=await this.estGasRemoveErc20Deployer(t,e,a,s);return await s.methods.removeFromCreateERC20List(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasAddMetadataUpdater(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addToMetadataList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addMetadataUpdater(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddMetadataUpdater(t,e,a,s);return await s.methods.addToMetadataList(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async esGasRemoveMetadataUpdater(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFromMetadataList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeMetadataUpdater(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Manager nor Metadata Updater");const i=await this.esGasRemoveMetadataUpdater(t,e,a,s);return await s.methods.removeFromMetadataList(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasAddStoreUpdater(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addTo725StoreList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addStoreUpdater(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddStoreUpdater(t,e,a,s);return await s.methods.addTo725StoreList(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasRemoveStoreUpdater(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFrom725StoreList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeStoreUpdater(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).store)throw new Error("Caller is not Manager nor storeUpdater");const i=await this.estGasRemoveStoreUpdater(t,e,a,s);return await s.methods.removeFrom725StoreList(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){const s=a||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.cleanPermissions().estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async cleanPermissions(t,e){const a=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const s=await this.estGasCleanPermissions(t,e,a);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await A(this.web3,this.config)})}async estGasTransferNft(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.transferFrom(e,a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async transferNft(t,e,a,s){const i=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=s||1,o=await this.estGasTransferNft(t,e,a,n,i);return await i.methods.transferFrom(e,a,n).send({from:e,gas:o+1,gasPrice:await A(this.web3,this.config)})}async estGasSafeTransferNft(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.safeTransferFrom(e,a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async safeTransferNft(t,e,a,s){const i=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=s||1,o=await this.estGasSafeTransferNft(t,e,a,n,i);return await i.methods.safeTransferFrom(e,a,n).send({from:e,gas:o+1,gasPrice:await A(this.web3,this.config)})}async estGasSetMetadata(t,e,a,s,i,n,o,r,c,h){const l=h||b(new this.web3.eth.Contract(this.nftAbi,t),this.config);c||(c=[]);const d=this.GASLIMIT_DEFAULT;let w;try{w=await l.methods.setMetaData(a,s,i,n,o,r,c).estimateGas({from:e},(t,e)=>t?d:e)}catch(t){g.error("estGasSetMetadata error: ",t.message),w=d}return w}async setMetadata(t,e,a,s,i,n,o,r,c){const h=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(c||(c=[]),!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const l=await this.estGasSetMetadata(t,e,a,s,i,n,o,r,c,h);return await h.methods.setMetaData(a,s,i,n,o,r,c).send({from:e,gas:l+1,gasPrice:await A(this.web3,this.config)})}async estGasSetMetadataAndTokenURI(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;const r=P({},a,{metadataProofs:a.metadataProofs||[]});try{o=await i.methods.setMetaDataAndTokenURI(r).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setMetadataAndTokenURI(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const i=await this.estGasSetMetadataAndTokenURI(t,e,a,s),n=P({},a,{metadataProofs:a.metadataProofs||[]});return await s.methods.setMetaDataAndTokenURI(n).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasSetMetadataState(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setMetaDataState(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setMetadataState(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const i=await this.estGasSetMetadataState(t,e,a);return await s.methods.setMetaDataState(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estSetTokenURI(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.setTokenURI("1",a).estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async setTokenURI(t,e,a){const s=b(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=await this.estSetTokenURI(t,e,a);return await s.methods.setTokenURI("1",a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async getNftOwner(t){const e=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.ownerOf(1).call()}async getNftPermissions(t,e){const a=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getPermissions(e).call()}async getMetadata(t){const e=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.getMetaData().call()}async isErc20Deployer(t,e){const a=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async getData(t,e){const a=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getData(e).call()}async getTokenURI(t,e){const a=b(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.tokenURI(e).call()}}class rt{constructor(t,e,a,s){this.GASLIMIT_DEFAULT=1e6,this.factoryAddress=void 0,this.factoryABI=void 0,this.datatokensAbi=void 0,this.datatokensEnterpriseAbi=void 0,this.web3=void 0,this.config=void 0,this.nft=void 0,this.web3=t,this.datatokensAbi=e||r.abi,this.datatokensEnterpriseAbi=a||l.abi,this.config=s||O[0],this.nft=new ot(this.web3)}async estGasApprove(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.approve(e,this.web3.utils.toWei(a)).estimateGas({from:s},(t,e)=>t?o:e)}catch(t){r=o}return r}async approve(t,e,a,s){const i=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=await this.estGasApprove(t,e,a,s,i);return await i.methods.approve(e,this.web3.utils.toWei(a)).send({from:s,gas:n+1,gasPrice:await A(this.web3,this.config)})}async estGasMint(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.mint(s||e,this.web3.utils.toWei(a)).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async estGasCreateFixedRate(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;a.allowedConsumer||(a.allowedConsumer="0x0000000000000000000000000000000000000000");const o=a.withMint?1:0;let r;try{r=await i.methods.createFixedRate(a.fixedRateAddress,[a.baseTokenAddress,e,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,o]).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){r=n}return r}async createFixedRate(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");a.allowedConsumer||(a.allowedConsumer="0x0000000000000000000000000000000000000000");const i=a.withMint?1:0,n=await this.estGasCreateFixedRate(t,e,a,s);return await s.methods.createFixedRate(a.fixedRateAddress,[a.baseTokenAddress,a.owner,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,i]).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}async estGasCreateDispenser(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);s.allowedSwapper||(s.allowedSwapper="0x0000000000000000000000000000000000000000"),s.withMint||(s.withMint=!1);const o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.createDispenser(a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async createDispenser(t,e,a,s){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const i=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);s.allowedSwapper||(s.allowedSwapper="0x0000000000000000000000000000000000000000"),s.withMint||(s.withMint=!1);const n=await this.estGasCreateDispenser(t,e,a,s,i);return await i.methods.createDispenser(a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}async mint(t,e,a,s){const i=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==(await this.getDTPermissions(t,e)).minter)throw new Error("Caller is not Minter");const o=await this.getCap(t);if(new n(o).gte(a)){const n=await this.estGasMint(t,e,a,s,i);return await i.methods.mint(s||e,this.web3.utils.toWei(a)).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}throw new Error("Mint amount exceeds cap available")}async estGasAddMinter(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addMinter(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addMinter(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasAddMinter(t,e,a,s);return await s.methods.addMinter(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasRemoveMinter(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeMinter(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeMinter(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasRemoveMinter(t,e,a,s);return await s.methods.removeMinter(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasAddPaymentManager(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addPaymentManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addPaymentManager(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasAddPaymentManager(t,e,a,s);return await s.methods.addPaymentManager(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasRemovePaymentManager(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removePaymentManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removePaymentManager(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasRemovePaymentManager(t,e,a,s);return await s.methods.removePaymentManager(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasSetPaymentCollector(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setPaymentCollector(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setPaymentCollector(t,e,a){const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=!0===(await this.getDTPermissions(t,e)).paymentManager,n=!i&&await this.getNFTAddress(t),o=n&&await this.nft.getNftOwner(n)===e,r=n&&!o&&await this.nft.getNftPermissions(n,e);if(!i&&!o&&!(null==r?void 0:r.deployERC20))throw new Error("Caller is not Fee Manager, owner or erc20 Deployer");const c=await this.estGasSetPaymentCollector(t,e,a,s);return await s.methods.setPaymentCollector(a).send({from:e,gas:c+1,gasPrice:await A(this.web3,this.config)})}async getPaymentCollector(t){const e=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getPaymentCollector().call()}async transfer(t,e,a,s){const i=this.web3.utils.toWei(a);return this.transferWei(t,e,i,s)}async estGasTransfer(t,e,a,s,i){const n=i||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.transfer(e,a).estimateGas({from:s},(t,e)=>t?o:e)}catch(t){r=o}return r}async transferWei(t,e,a,s){const i=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);try{const n=await this.estGasTransfer(t,e,a,s,i);return await i.methods.transfer(e,a).send({from:s,gas:n+1,gasPrice:await A(this.web3,this.config)})}catch(t){throw g.error(`ERROR: Failed to transfer tokens: ${t.message}`),new Error(`Failed Failed to transfer tokens: ${t.message}`)}}async estGasStartOrder(t,e,a,s,i,n,o){const r=o||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.startOrder(a,s,i,n).estimateGas({from:e},(t,e)=>t?c:e)}catch(t){h=c}return h}async startOrder(t,e,a,s,i,o){var r=this;const c=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);o||(o={consumeMarketFeeAddress:"0x0000000000000000000000000000000000000000",consumeMarketFeeToken:"0x0000000000000000000000000000000000000000",consumeMarketFeeAmount:"0"});const h=await c.methods.getPublishingMarketFee().call(),l=[{token:i.providerFeeToken,feeAmount:i.providerFeeAmount},{token:o.consumeMarketFeeToken,feeAmount:parseFloat(o.consumeMarketFeeAmount)},{token:h[1],feeAmount:parseFloat(h[2])}],d=[];l.map(t=>{d.length>0?d.map(e=>{e.token===t.token?e.feeAmount+=t.feeAmount:d.push({token:t.token,feeAmount:t.feeAmount})}):d.push({token:t.token,feeAmount:t.feeAmount})});const w=d.map(async function(t){if(t.token===N||0===t.feeAmount)return t;const s=await z(r.web3,t.token,e,a);if(new n(s).greaterThanOrEqualTo(new n(t.feeAmount)))throw g.error(`ERROR: Failed checking allowance: ${t.token}`),new Error(`allowance (${s}) is too low`);return t.currentAllowance=s,t});try{await Promise.all(w)}catch(t){throw g.error(`ERROR: Failed checking allowance : ${t}`),new Error(`Failed checking allowance: ${t}`)}try{const n=await this.estGasStartOrder(t,e,a,s,i,o,c);return await c.methods.startOrder(a,s,i,o).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}catch(t){throw g.error(`ERROR: Failed to start order : ${t.message}`),new Error(`Failed to start order: ${t.message}`)}}async estGasBuyFromFreAndOrder(t,e,a,s,i){const n=i||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.buyFromFreAndOrder(a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async buyFromFreAndOrder(t,e,a,s){const i=new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t);try{const n=E(s),o=await this.estGasBuyFromFreAndOrder(t,e,a,n,i);return await i.methods.buyFromFreAndOrder(a,n).send({from:e,gas:o+1,gasPrice:await A(this.web3,this.config)})}catch(t){throw g.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasBuyFromDispenserAndOrder(t,e,a,s,i){const n=i||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.buyFromDispenserAndOrder(a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async buyFromDispenserAndOrder(t,e,a,s){const i=new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t);try{const n=await this.estGasBuyFromDispenserAndOrder(t,e,a,s,i);return await i.methods.buyFromDispenserAndOrder(a,s).send({from:e,gas:n+1,gasPrice:await A(this.web3,this.config)})}catch(t){throw g.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasSetData(t,e,a,s){const i=s||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setData(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setData(t,e,a){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const s=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=await this.estGasSetData(t,e,a,s);return await s.methods.setData(a).send({from:e,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){const s=a||b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.cleanPermissions().estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async cleanPermissions(t,e){if(await this.nft.getNftOwner(await this.getNFTAddress(t))!==e)throw new Error("Caller is NOT Nft Owner");const a=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),s=await this.estGasCleanPermissions(t,e,a);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await A(this.web3,this.config)})}async getDTPermissions(t,e){const a=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.permissions(e).call()}async getCap(t){const e=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),a=await e.methods.cap().call();return this.web3.utils.fromWei(a)}async getDecimals(t){const e=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.decimals().call()}async getNFTAddress(t){const e=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getERC721Address().call()}async isERC20Deployer(t,e){const a=b(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async balance(t,e){const a=new this.web3.eth.Contract(this.datatokensAbi,t,{from:e}),s=await a.methods.balanceOf(e).call();return this.web3.utils.fromWei(s)}}const ct="0x0000000000000000000000000000000000000000";class ht{constructor(t,e,a,s){this.GASLIMIT_DEFAULT=1e6,this.factory721Address=void 0,this.factory721Abi=void 0,this.web3=void 0,this.config=void 0,this.factory721=void 0,this.factory721Address=t,this.factory721Abi=a||w.abi,this.web3=e,this.config=s||O[0],this.factory721=b(new this.web3.eth.Contract(this.factory721Abi,this.factory721Address),this.config)}async estGasCreateNFT(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.deployERC721Contract(e.name,e.symbol,e.templateIndex,ct,ct,e.tokenURI,e.transferable,e.owner).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async createNFT(t,e){if(e.templateIndex||(e.templateIndex=1),!e.name||!e.symbol){const{name:t,symbol:a}=f();e.name=t,e.symbol=a}if(e.templateIndex>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e.templateIndex)throw new Error("Template index cannot be ZERO");if(!1===(await this.getNFTTemplate(e.templateIndex)).isActive)throw new Error("Template is not active");const a=await this.estGasCreateNFT(t,e),s=await this.factory721.methods.deployERC721Contract(e.name,e.symbol,e.templateIndex,ct,ct,e.tokenURI,e.transferable,e.owner).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)});let i=null;try{i=s.events.NFTCreated.returnValues[0]}catch(t){g.error(`ERROR: Failed to create datatoken : ${t.message}`)}return i}async getCurrentNFTCount(){return await this.factory721.methods.getCurrentNFTCount().call()}async getCurrentTokenCount(){return await this.factory721.methods.getCurrentTokenCount().call()}async getOwner(){return await this.factory721.methods.owner().call()}async getCurrentNFTTemplateCount(){return await this.factory721.methods.getCurrentNFTTemplateCount().call()}async getCurrentTokenTemplateCount(){return await this.factory721.methods.getCurrentTemplateCount().call()}async getNFTTemplate(t){if(t>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===t)throw new Error("Template index cannot be ZERO");return await this.factory721.methods.getNFTTemplate(t).call()}async getTokenTemplate(t){return await this.factory721.methods.getTokenTemplate(t).call()}async checkDatatoken(t){return await this.factory721.methods.erc20List(t).call()}async checkNFT(t){return await this.factory721.methods.erc721List(t).call()}async estGasAddNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.add721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===ct)throw new Error("Template cannot be ZERO address");const a=await this.estGasAddNFTTemplate(t,e);return await this.factory721.methods.add721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasDisableNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.disable721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async disableNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await this.estGasDisableNFTTemplate(t,e);return await this.factory721.methods.disable721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasReactivateNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.reactivate721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async reactivateNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await this.estGasReactivateNFTTemplate(t,e);return await this.factory721.methods.reactivate721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasAddTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.addTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===ct)throw new Error("Template cannot be address ZERO");const a=await this.estGasAddTokenTemplate(t,e);return await this.factory721.methods.addTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasDisableTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.disableTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async disableTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!1===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already disabled");const a=await this.estGasDisableTokenTemplate(t,e);return await this.factory721.methods.disableTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasReactivateTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.reactivateTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async reactivateTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!0===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already active");const a=await this.estGasReactivateTokenTemplate(t,e);return await this.factory721.methods.reactivateTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasStartMultipleTokenOrder(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.startMultipleTokenOrder(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async startMultipleTokenOrder(t,e){if(e.length>50)throw new Error("Too many orders");const a=await this.estGasStartMultipleTokenOrder(t,e);return await this.factory721.methods.startMultipleTokenOrder(e).send({from:t,gas:a+1,gasPrice:await A(this.web3,this.config)})}async estGasCreateNftWithErc20(t,e,a){const s=this.GASLIMIT_DEFAULT;let i;try{const n=T(a);i=await this.factory721.methods.createNftWithErc20(e,n).estimateGas({from:t},(t,e)=>t?s:e)}catch(t){i=s}return i}async createNftWithErc20(t,e,a){const s=T(a),i=await this.estGasCreateNftWithErc20(t,e,a);return await this.factory721.methods.createNftWithErc20(e,s).send({from:t,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasCreateNftErc20WithPool(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;try{const o=T(a),r=await k(this.web3,s);n=await this.factory721.methods.createNftWithErc20WithPool(e,o,r).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async createNftErc20WithPool(t,e,a,s){const i=await this.estGasCreateNftErc20WithPool(t,e,a,s),n=T(a),o=await k(this.web3,s);return await this.factory721.methods.createNftWithErc20WithPool(e,n,o).send({from:t,gas:i+1,gasPrice:await A(this.web3,this.config)})}async estGasCreateNftErc20WithFixedRate(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;const o=T(a),r=await C(s);try{n=await this.factory721.methods.createNftWithErc20WithFixedRate(e,o,r).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async createNftErc20WithFixedRate(t,e,a,s){const i=T(a),n=C(s),o=await this.estGasCreateNftErc20WithFixedRate(t,e,a,s);return await this.factory721.methods.createNftWithErc20WithFixedRate(e,i,n).send({from:t,gas:o+1,gasPrice:await A(this.web3,this.config)})}async estGasCreateNftErc20WithDispenser(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;const o=T(a);try{n=await this.factory721.methods.createNftWithErc20WithDispenser(e,o,s).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i,g.error("Failed to estimate gas for createNftErc20WithDispenser",t)}return n}async createNftErc20WithDispenser(e,a,s,i){const n=T(s);i.maxBalance=t.utils.toWei(i.maxBalance),i.maxTokens=t.utils.toWei(i.maxTokens);const o=await this.estGasCreateNftErc20WithDispenser(e,a,s,i);return await this.factory721.methods.createNftWithErc20WithDispenser(a,n,i).send({from:e,gas:o+1,gasPrice:await A(this.web3,this.config)})}}class lt{constructor(){this.nodeUri=void 0,this.providerAddress=void 0,this.metadataCacheUri=void 0,this.providerUri=void 0,this.web3Provider=void 0,this.oceanTokenAddress=void 0,this.erc721FactoryAddress=void 0,this.erc721FFactoryABI=void 0,this.datatokensABI=void 0,this.poolTemplateAddress=void 0,this.poolFactoryABI=void 0,this.poolABI=void 0,this.fixedRateExchangeAddress=void 0,this.fixedRateExchangeAddressABI=void 0,this.dispenserAddress=void 0,this.dispenserABI=void 0,this.opfCommunityFeeCollector=void 0,this.sideStakingAddress=void 0,this.startBlock=void 0,this.verbose=void 0,this.authMessage=void 0,this.authTokenExpiration=void 0,this.parityUri=void 0,this.threshold=void 0,this.chainId=void 0,this.network=void 0,this.subgraphUri=void 0,this.explorerUri=void 0,this.oceanTokenSymbol=void 0,this.transactionBlockTimeout=void 0,this.transactionConfirmationBlocks=void 0,this.transactionPollingTimeout=void 0,this.gasFeeMultiplier=void 0}}const dt=t=>function(t="",e){const{valid:a,output:s}=function(t,e,a){if("string"!=typeof t)throw g.debug("Not input string:"),g.debug(t),new Error("[zeroXTransformer] Expected string, input type: "+typeof t);const s=t.match(/^(?:0x)*([a-f0-9]+)$/i);return s?{valid:!0,output:s[1]}:(g.warn("[zeroXTransformer] Input transformation failed."),{valid:!1,output:t})}(t);return(e&&a?"0x":"")+s}(t,!1);class wt{async getEndpoints(t){try{const e=await G(t);return await e.json()}catch(t){return g.error("Finding the service endpoints failed:",t),null}}getEndpointURL(t,e){return t?t.find(t=>t.serviceName===e):null}async getServiceEndpoints(t,e){const a=[];for(const s in e.serviceEndpoints)a.push({serviceName:s,method:e.serviceEndpoints[s][0],urlPath:t+e.serviceEndpoints[s][1]});return a}async getNonce(t,e,s,i,n){i||(i=await this.getEndpoints(t)),n||(n=await this.getServiceEndpoints(t,i));const o=this.getEndpointURL(n,"nonce")?this.getEndpointURL(n,"nonce").urlPath:null;if(!o)return null;try{const t=await a(o+`?userAddress=${e}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});return(await t.json()).nonce.toString()}catch(t){throw g.error(t),new Error("HTTP request failed")}}async createSignature(t,e,a){return await W(t,dt(a),e)}async createHashSignature(t,e,a){return await B(t,a,e)}async encrypt(t,e,s){const i=await this.getEndpoints(e),n=await this.getServiceEndpoints(e,i),o=this.getEndpointURL(n,"encrypt")?this.getEndpointURL(n,"encrypt").urlPath:null;if(!o)return null;try{const e=await a(o,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:s});return await e.text()}catch(t){throw g.error(t),new Error("HTTP request failed")}}async checkDidFiles(t,e,s,i){const n=await this.getEndpoints(s),o=await this.getServiceEndpoints(s,n),r={did:t,serviceId:e},c=[],h=this.getEndpointURL(o,"fileinfo")?this.getEndpointURL(o,"fileinfo").urlPath:null;if(!h)return null;try{const t=await a(h,{method:"POST",body:JSON.stringify(r),headers:{"Content-Type":"application/json"},signal:i}),e=await t.json();for(const t of e)c.push(t);return c}catch(t){return null}}async checkFileUrl(t,e,s){const i=await this.getEndpoints(e),n=await this.getServiceEndpoints(e,i),o={url:t,type:"url"},r=[],c=this.getEndpointURL(n,"fileinfo")?this.getEndpointURL(n,"fileinfo").urlPath:null;if(!c)return null;try{const t=await a(c,{method:"POST",body:JSON.stringify(o),headers:{"Content-Type":"application/json"},signal:s}),e=await t.json();for(const t of e)r.push(t);return r}catch(t){return null}}async getComputeEnvironments(t,e){var s;const i=await this.getEndpoints(t),n=await this.getServiceEndpoints(t,i),o=null==(s=this.getEndpointURL(n,"computeEnvironments"))?void 0:s.urlPath;if(!o)return null;try{const t=await a(o,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});return await t.json()}catch(t){return g.error(t.message),null}}async initialize(t,e,s,i,n,o,r,c,h){const l=await this.getEndpoints(n),d=await this.getServiceEndpoints(n,l);let w=this.getEndpointURL(d,"initialize")?this.getEndpointURL(d,"initialize").urlPath:null;if(!w)return null;w+=`?documentId=${t}`,w+=`&serviceId=${e}`,w+=`&fileIndex=${s}`,w+=`&consumerAddress=${i}`,r&&(w+="&userdata="+encodeURI(JSON.stringify(r))),c&&(w+="&environment="+encodeURI(c)),h&&(w+="&validUntil="+h);try{const t=await a(w,{method:"GET",headers:{"Content-Type":"application/json"},signal:o});return await t.json()}catch(t){throw g.error(t),new Error("Asset URL not found or not available.")}}async getDownloadUrl(t,e,a,s,i,n,o,r){const c=await this.getEndpoints(n),h=await this.getServiceEndpoints(n,c),l=this.getEndpointURL(h,"download")?this.getEndpointURL(h,"download").urlPath:null;if(!l)return null;const d=Date.now();let w=l;return w+=`?fileIndex=${s}`,w+=`&documentId=${t}`,w+=`&transferTxId=${i}`,w+=`&serviceId=${a}`,w+=`&consumerAddress=${e}`,w+=`&nonce=${d}`,w+=`&signature=${await this.createSignature(o,e,t+d)}`,r&&(w+="&userdata="+encodeURI(JSON.stringify(r))),w}async computeStart(t,e,s,i,n,o,r,c,h){const l=await this.getEndpoints(t),d=await this.getServiceEndpoints(t,l),w=this.getEndpointURL(d,"computeStart")?this.getEndpointURL(d,"computeStart").urlPath:null,u=Date.now();let m=s;m+=n.documentId,m+=u;const p=await this.createHashSignature(e,s,m),f=Object();if(f.consumerAddress=s,f.signature=p,f.nonce=u,f.environment=i,f.dataset=n,f.algorithm=o,f.additionalDatasets&&(f.additionalDatasets=c),h&&(f.output=h),!w)return null;try{const t=await a(w,{method:"POST",body:JSON.stringify(f),headers:{"Content-Type":"application/json"},signal:r});return null!=t&&t.ok?await t.json():(console.error("Compute start failed:",t.status,t.statusText),g.error("Payload was:",f),null)}catch(t){return g.error("Compute start failed:"),g.error(t),g.error("Payload was:",f),null}}async computeStop(t,e,s,i,n,o){const r=await this.getEndpoints(i),c=await this.getServiceEndpoints(i,r),h=this.getEndpointURL(c,"computeStop")?this.getEndpointURL(c,"computeStop").urlPath:null,l=await this.getNonce(i,e,o,r,c);let d=e;d+=s||"",d+=t&&`${dt(t)}`||"",d+=l;const w=await this.createHashSignature(n,e,d),u=Object();if(u.signature=w,u.documentId=dt(t),u.consumerAddress=e,s&&(u.jobId=s),!h)return null;try{const t=await a(h,{method:"PUT",body:JSON.stringify(u),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(g.error("Compute stop failed:",t.status,t.statusText),g.error("Payload was:",u),null)}catch(t){return g.error("Compute stop failed:"),g.error(t),g.error("Payload was:",u),null}}async computeStatus(t,e,s,i,n){const o=await this.getEndpoints(t),r=await this.getServiceEndpoints(t,o),c=this.getEndpointURL(r,"computeStatus")?this.getEndpointURL(r,"computeStatus").urlPath:null;let h=`?consumerAddress=${e}`;if(h+=i&&`&documentId=${dt(i)}`||"",h+=s&&`&jobId=${s}`||"",!c)return null;try{const t=await a(c+h,{method:"GET",headers:{"Content-Type":"application/json"},signal:n});return null!=t&&t.ok?await t.json():(g.error("Get compute status failed:",t.status,t.statusText),null)}catch(t){return g.error("Get compute status failed"),g.error(t),null}}async getComputeResultUrl(t,e,a,s,i){const n=await this.getEndpoints(t);console.log("computeResult providerEndpoints: ",n);const o=await this.getServiceEndpoints(t,n);console.log("computeResult serviceEndpoints: ",o);const r=this.getEndpointURL(o,"computeResult")?this.getEndpointURL(o,"computeResult").urlPath:null;console.log("computeResult computeResultUrl: ",r);const c=Date.now();let h=a;h+=s,h+=i.toString(),h+=c;const l=await this.createHashSignature(e,a,h);let d=r;return d+=`?consumerAddress=${a}`,d+=`&jobId=${s}`,d+=`&index=${i.toString()}`,d+=`&nonce=${c}`,d+=l&&`&signature=${l}`||"",console.log("computeResult resultUrl: ",d),d||null}async computeDelete(t,e,s,i,n,o){const r=await this.getEndpoints(i),c=await this.getServiceEndpoints(i,r),h=this.getEndpointURL(c,"computeDelete")?this.getEndpointURL(c,"computeDelete").urlPath:null,l=await this.getNonce(i,e,o,r,c);let d=e;d+=s||"",d+=t&&`${dt(t)}`||"",d+=l;const w=await this.createHashSignature(n,e,d),u=Object();if(u.documentId=dt(t),u.consumerAddress=e,u.jobId=s,w&&(u.signature=w),!h)return null;try{const t=await a(h,{method:"DELETE",body:JSON.stringify(u),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(g.error("Delete compute job failed:",t.status,t.statusText),g.error("Payload was:",u),null)}catch(t){return g.error("Delete compute job failed:"),g.error(t),g.error("Payload was:",u),null}}async isValidProvider(t,e){try{const s=await a(t,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(null!=s&&s.ok){const t=await s.json();if(t&&t.providerAddress)return!0}return!1}catch(t){return g.error(`Error validating provider: ${t.message}`),!1}}}const ut=new wt;export{tt as Aquarius,lt as Config,U as ConfigHelper,rt as Datatoken,st as Dispenser,it as FixedRateCreateProgressStep,nt as FixedRateExchange,$ as GASLIMIT_DEFAULT,u as LogLevel,m as Logger,g as LoggerInstance,ot as Nft,ht as NftFactory,at as Pool,wt as Provider,ut as ProviderInstance,N as ZERO_ADDRESS,z as allowance,v as amountToUnits,q as approve,J as balance,V as calcMaxExactIn,Z as calcMaxExactOut,O as configHelperNetworks,S as downloadFile,I as downloadFileBrowser,j as estApprove,R as fetchData,L as generateDid,f as generateDtName,G as getData,T as getErcCreationParams,A as getFairGasPrice,C as getFreCreationParams,E as getFreOrderParams,D as getHash,K as getMaxAddLiquidity,Y as getMaxRemoveLiquidity,Q as getMaxSwapExactIn,X as getMaxSwapExactOut,k as getPoolCreationParams,M as postData,b as setContractDefaults,_ as signHash,W as signText,B as signWithHash,H as sleep,F as unitsToAmount};
//# sourceMappingURL=lib.modern.js.map
