{"version":3,"file":"lib.modern.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/DdoHelpers.ts","../src/utils/Constants.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/models/Config.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { Config } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  console.log(\n    'contract config ',\n    config.transactionBlockTimeout,\n    config.transactionConfirmationBlocks,\n    config.transactionPollingTimeout\n  )\n  console.log(\n    'contract value ',\n    contract.transactionBlockTimeout,\n    contract.transactionConfirmationBlocks,\n    contract.transactionPollingTimeout\n  )\n  return contract\n}\n\nexport async function getFairGasPrice(web3: Web3, config: Config): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  console.log('getFairGasPrice ', config?.gasFeeMultiplier)\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport function getFreOrderParams(freParams: FreOrderParams): any {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: Web3.utils.toWei(freParams.maxBaseTokenAmount),\n    swapMarketFee: Web3.utils.toWei(freParams.swapMarketFee),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer)\n    freParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const anchor = document.createElement('a')\n  anchor.download = ''\n  anchor.href = url\n  anchor.click()\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signText(\n  web3: Web3,\n  text: string,\n  publicKey: string,\n  password?: string\n): Promise<string> {\n  const isMetaMask =\n    web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n  try {\n    return await web3.eth.personal.sign(text, publicKey, password)\n  } catch (e) {\n    if (isMetaMask) {\n      throw e\n    }\n    LoggerInstance.warn('Error on personal sign.')\n    LoggerInstance.warn(e)\n    try {\n      return await web3.eth.sign(text, publicKey)\n    } catch (e2) {\n      LoggerInstance.error('Error on sign.')\n      LoggerInstance.error(e2)\n      throw new Error('Error executing personal sign')\n    }\n  }\n}\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n\nexport async function signWithHash(\n  web3: Web3,\n  text: string,\n  publicKey: string,\n  password?: string\n): Promise<string> {\n  const hash = web3.utils.utf8ToHex(text)\n  const isMetaMask =\n    web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n  try {\n    return await web3.eth.personal.sign(hash, publicKey, password)\n  } catch (e) {\n    if (isMetaMask) {\n      throw e\n    }\n    LoggerInstance.warn('Error on personal sign.')\n    LoggerInstance.warn(e)\n    try {\n      return await web3.eth.sign(hash, publicKey)\n    } catch (e2) {\n      LoggerInstance.error('Error on sign.')\n      LoggerInstance.error(e2)\n      throw new Error('Error executing personal sign')\n    }\n  }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport { amountToUnits, getFairGasPrice, unitsToAmount } from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { GASLIMIT_DEFAULT } from '.'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  const gasLimitDefault = GASLIMIT_DEFAULT\n  let estGas\n  try {\n    estGas = await tokenContract.methods\n      .approve(spender, amount)\n      .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n  } catch (e) {\n    estGas = gasLimitDefault\n    LoggerInstance.error('estimate gas failed for approve!', e)\n  }\n  return estGas\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount  (always expressed as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowence\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await estApprove(\n    web3,\n    account,\n    tokenAddress,\n    spender,\n    amountFormatted,\n    tokenContract\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERRPR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(3.01)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2.01)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  private config: Config\n\n  constructor(web3: Web3, poolAbi: AbiItem | AbiItem[] = null, config?: Config) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .setSwapFee(fee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estSetSwapFee(account, poolAddress, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get OPC Collector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getOPCCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {String}\n   */\n  async getReserve(poolAddress: string, token: string): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getMarketFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getCommunityFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectOPC()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectOPC(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectMarketFee()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectMarketFee(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .updatePublishMarketFee(newPublishMarketAddress, newPublishMarketSwapFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estUpdatePublishMarketFee(\n      address,\n      poolAddress,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountIn(\n      address,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    let result = null\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountOut(\n      account,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinPool method\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinPool(poolAmountOut, maxAmountsIn)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Adds dual side liquidity to the pool (both datatoken and basetoken)\n   * This will pull some of each of the currently trading tokens in the pool,\n   * meaning you must have called approve for each token for this pool.\n   * These values are limited by the array of maxAmountsIn in the order of the pool tokens.\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @return {TransactionReceipt}\n   */\n  async joinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMaxAmountsIn = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], maxAmountsIn[i])\n      weiMaxAmountsIn.push(amount)\n    }\n\n    let result = null\n\n    const estGas = await this.estJoinPool(\n      address,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountOut),\n      weiMaxAmountsIn\n    )\n\n    try {\n      result = await pool.methods\n        .joinPool(this.web3.utils.toWei(poolAmountOut), weiMaxAmountsIn)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to join pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitPool\n   * @param {String} address\n   * @param {String} poolAddress\n ``* @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut  aarray with minimum amount of tokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitPool(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitPool(poolAmountIn, minAmountsOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes dual side liquidity from the pool (both datatoken and basetoken)\n   * Exit the pool, paying poolAmountIn pool tokens and getting some of each of the currently trading tokens in return.\n   * These values are limited by the array of minAmountsOut in the order of the pool tokens.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut array with minimum amount of tokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitPool(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMinAmountsOut = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], minAmountsOut[i])\n      weiMinAmountsOut.push(amount)\n    }\n    let result = null\n    const estGas = await this.estExitPool(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      weiMinAmountsOut\n    )\n\n    try {\n      result = await pool.methods\n        .exitPool(this.web3.utils.toWei(poolAmountIn), weiMinAmountsOut)\n        .send({\n          from: account,\n          gas: estGas,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to exit pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinswapExternAmountIn(tokenAmountIn, minPoolAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n    const estGas = await this.estJoinswapExternAmountIn(\n      account,\n      poolAddress,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitswapPoolAmountIn(poolAmountIn, minTokenAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await amountToUnits(\n      this.web3,\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut\n    )\n    const estGas = await this.estExitswapPoolAmountIn(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenIn)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountIn),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param _consumeMarketSwapFee consume market swap fee\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountOut),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await amountToUnits(this.web3, poolAddress, poolAmountOut)\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n\n        .call()\n\n      amount = await unitsToAmount(this.web3, tokenIn, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await amountToUnits(this.web3, poolAddress, poolAmountIn)\n        )\n        .call()\n      amount = await unitsToAmount(this.web3, tokenOut, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_SWAP' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_JOIN' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_EXIT' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public GASLIMIT_DEFAULT = 1000000\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.dispenserContract.methods\n        .create(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance),\n          address,\n          allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreate(\n      dtAddress,\n      address,\n      maxTokens,\n      maxBalance,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasActivate(dtAddress, maxTokens, maxBalance, address)\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .deactivate(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasDeactivate(dtAddress, address)\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasSetAllowedSwapper(\n        dtAddress,\n        address,\n        newAllowedSwapper\n      )\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasDispense(dtAddress, address, amount, destination)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasOwnerWithdraw(dtAddress, address)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  public GASLIMIT_DEFAULT = 1000000\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public fixedRateContract: Contract\n  public web3: Web3\n  public contract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    console.log('contract FRE config ', this.config)\n    this.contract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(token: string, amount: string): Promise<string> {\n    return amountToUnits(this.web3, token, amount)\n  }\n\n  async unitsToAmount(token: string, amount: string): Promise<string> {\n    return unitsToAmount(this.web3, token, amount)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .buyDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = '0x0000000000000000000000000000000000000000',\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount\n    )\n\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .sellDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = '0x0000000000000000000000000000000000000000',\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount\n    )\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, await this.web3.utils.toWei(newRate))\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(address, exchangeId, newRate)\n    const trxReceipt = await this.contract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, newAllowedSwapper)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetAllowedSwapper(address, exchangeId, newAllowedSwapper)\n    const trxReceipt = await this.contract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n\n    const estGas = await this.estActivate(address, exchangeId)\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).datatoken,\n      dtSupply\n    )\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      btSupply\n    )\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    console.log(\n      'contract calcBaseInGivenOutDT config ',\n      this.contract.transactionBlockTimeout,\n      this.contract.transactionConfirmationBlocks,\n      this.contract.transactionPollingTimeout\n    )\n    const result = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(fixedRateExchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(exchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result[0]\n    )\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(result.datatoken, result.dtBalance)\n    result.btBalance = await this.unitsToAmount(result.baseToken, result.btBalance)\n    result.dtSupply = await this.unitsToAmount(result.datatoken, result.dtSupply)\n    result.btSupply = await this.unitsToAmount(result.baseToken, result.btSupply)\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    result.marketFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.marketFeeAvailable\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.oceanFeeAvailable\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.contract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId, true)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await this.estActivateMint(address, exchangeId)\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectBT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectBT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    const trxReceipt = await this.contract.methods.collectBT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectDT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectDT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    const trxReceipt = await this.contract.methods.collectDT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectMarketFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectMarketFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectOceanFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectOceanFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFee(exchangeId, newMarketFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(\n      address,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estUpdateMarketFeeCollector(\n      address,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  configHelperNetworks\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(web3: Web3, nftAbi?: AbiItem | AbiItem[], config?: Config) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .createERC20(\n          templateIndex,\n          [name, symbol],\n          [minter, paymentCollector, mpFeeAddress, feeToken],\n          [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n          []\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCreateErc20(\n      nftAddress,\n      address,\n      minter,\n      paymentCollector,\n      mpFeeAddress,\n      feeToken,\n      feeAmount,\n      cap,\n      name,\n      symbol,\n      templateIndex,\n      nftContract\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasAddManager(nftAddress, address, manager, nftContract)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasRemoveManager(\n      nftAddress,\n      address,\n      manager,\n      nftContract\n    )\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToCreateERC20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await this.estGasAddErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromCreateErc20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await this.estGasRemoveErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addTo725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFrom725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await this.estGasRemoveStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasCleanPermissions(nftAddress, address, nftContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .transferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .safeTransferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasSafeTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaData(\n          metadataState,\n          metadataDecryptorUrl,\n          metadataDecryptorAddress,\n          flags,\n          data,\n          metadataHash,\n          metadataProofs\n        )\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      LoggerInstance.error('estGasSetMetadata error: ', e.message)\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadata(\n      nftAddress,\n      address,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs,\n      nftContract\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadataAndTokenURI(\n      nftAddress,\n      metadataUpdater,\n      metadataAndTokenURI,\n      nftContract\n    )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataState(metadataState)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await this.estGasSetMetadataState(nftAddress, address, metadataState)\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setTokenURI('1', data)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estSetTokenURI(nftAddress, address, data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.getData(key).call()\n    return data\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  configHelperNetworks,\n  getFreOrderParams,\n  allowance,\n  ZERO_ADDRESS\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public GASLIMIT_DEFAULT = 1000000\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for mint method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .approve(spender, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasApprove(\n      dtAddress,\n      spender,\n      amount,\n      address,\n      dtContract\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    if (!fixedRateParams.allowedConsumer)\n      fixedRateParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createFixedRate(\n          fixedRateParams.fixedRateAddress,\n          [\n            fixedRateParams.baseTokenAddress,\n            address,\n            fixedRateParams.marketFeeCollector,\n            fixedRateParams.allowedConsumer\n          ],\n          [\n            fixedRateParams.baseTokenDecimals,\n            fixedRateParams.datatokenDecimals,\n            fixedRateParams.fixedRate,\n            fixedRateParams.marketFee,\n            withMint\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer)\n      fixedRateParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateFixedRate(\n      dtAddress,\n      address,\n      fixedRateParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper)\n      dispenserParams.allowedSwapper = '0x0000000000000000000000000000000000000000'\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createDispenser(\n          dispenserAddress,\n          dispenserParams.maxTokens,\n          dispenserParams.maxBalance,\n          dispenserParams.withMint,\n          dispenserParams.allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper)\n      dispenserParams.allowedSwapper = '0x0000000000000000000000000000000000000000'\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateDispenser(\n      dtAddress,\n      address,\n      dispenserAddress,\n      dispenserParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await this.estGasMint(\n        dtAddress,\n        address,\n        amount,\n        toAddress,\n        dtContract\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for addMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await this.estGasAddMinter(dtAddress, address, minter, dtContract)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    // Estimate gas for removeMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removeMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemoveMinter(dtAddress, address, minter, dtContract)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for addFeeManager method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addPaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasAddPaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removePaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemovePaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setPaymentCollector(paymentCollector)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager =\n      (await this.getDTPermissions(dtAddress, address)).paymentManager === true\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await this.estGasSetPaymentCollector(\n      dtAddress,\n      address,\n      paymentCollector,\n      dtContract\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .transfer(toAddress, amount)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasTransfer(\n        dtAddress,\n        toAddress,\n        amount,\n        address,\n        dtContract\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: '0x0000000000000000000000000000000000000000',\n        consumeMarketFeeToken: '0x0000000000000000000000000000000000000000',\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await this.estGasStartOrder(\n        dtAddress,\n        address,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n    try {\n      const freContractParams = getFreOrderParams(freParams)\n\n      const estGas = await this.estGasBuyFromFreAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        freContractParams,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n    try {\n      const estGas = await this.estGasBuyFromDispenserAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        dispenserContract,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setData(value)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasSetData(dtAddress, address, value, dtContract)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(value).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCleanPermissions(dtAddress, address, dtContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  configHelperNetworks,\n  setContractDefaults\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\nconst addressZERO = '0x0000000000000000000000000000000000000000'\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .deployERC721Contract(\n          nftData.name,\n          nftData.symbol,\n          nftData.templateIndex,\n          addressZERO,\n          addressZERO,\n          nftData.tokenURI,\n          nftData.transferable,\n          nftData.owner\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await this.estGasCreateNFT(address, nftData)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        addressZERO,\n        addressZERO,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .add721TokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === addressZERO) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await this.estGasAddNFTTemplate(address, templateAddress)\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disable721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await this.estGasDisableNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivate721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await this.estGasReactivateNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .addTokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === addressZERO) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await this.estGasAddTokenTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disableTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await this.estGasDisableTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivateTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await this.estGasReactivateTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .startMultipleTokenOrder(orders)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await this.estGasStartMultipleTokenOrder(address, orders)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    // Get estimated gas value\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20(nftCreateData, ercCreateData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await this.estGasCreateNftWithErc20(address, nftCreateData, ercParams)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      const poolData = await getPoolCreationParams(this.web3, poolParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreateNftErc20WithPool(\n      address,\n      nftCreateData,\n      ercParams,\n      poolParams\n    )\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await this.estGasCreateNftErc20WithFixedRate(\n      address,\n      nftCreateData,\n      ercParams,\n      freParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n      LoggerInstance.error('Failed to estimate gas for createNftErc20WithDispenser', e)\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await this.estGasCreateNftErc20WithDispenser(\n      address,\n      nftCreateData,\n      ercParams,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n}\n\nexport default Config\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData, downloadFile, downloadFileBrowser } from '../utils'\nimport {\n  FileMetadata,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport { signText, signWithHash } from '../utils/SignatureUtils'\nimport fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types/DownloadResponse'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async createSignature(\n    web3: Web3,\n    accountId: string,\n    agreementId: string\n  ): Promise<string> {\n    const signature = await signText(web3, noZeroX(agreementId), accountId)\n    return signature\n  }\n\n  public async createHashSignature(\n    web3: Web3,\n    accountId: string,\n    message: string\n  ): Promise<string> {\n    const signature = await signWithHash(web3, message, accountId)\n    return signature\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url' }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.createSignature(web3, accountId, did + nonce)\n\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      console.error('Compute start failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @param {AbortSignal} signal Abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    console.log('computeResult computeResultUrl: ', computeResultUrl)\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n\n    console.log('computeResult resultUrl: ', resultUrl)\n    if (!resultUrl) return null\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n"],"names":["LogLevel","Logger","constructor","logLevel","Error","this","setLevel","bypass","args","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","setContractDefaults","contract","config","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getFairGasPrice","web3","x","BigNumber","eth","getGasPrice","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","toString","getErcCreationParams","ercParams","templateIndex","strings","addresses","minter","paymentCollector","mpFeeAddress","feeToken","uints","Web3","utils","toWei","cap","feeAmount","bytess","getFreOrderParams","freParams","exchangeContract","exchangeId","maxBaseTokenAmount","swapMarketFee","marketFeeAddress","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","baseTokenAddress","owner","marketFeeCollector","baseTokenDecimals","datatokenDecimals","fixedRate","marketFee","getPoolCreationParams","poolParams","ssContract","baseTokenSender","publisherAddress","poolTemplateAddress","ssParams","rate","vestingAmount","vestedBlocks","amountToUnits","initialBaseTokenLiquidity","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","unitsToAmount","token","amount","tokenContract","Contract","decimals","methods","call","amountFormatted","div","exponentiatedBy","EXPONENTIAL_AT","e","message","times","fetchData","url","opts","result","fetch","ok","method","text","downloadFileBrowser","anchor","document","createElement","download","href","click","downloadFile","index","response","filename","headers","get","match","split","pop","data","arrayBuffer","getData","postData","payload","async","body","postWithHeaders","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","FixedPrice","Dispenser","Staking","poolTemplate","ERC721Factory","OPFCommunityFeeCollector","Ocean","erc721FactoryAddress","sideStakingAddress","opfCommunityFeeCollector","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","generateDid","erc721Address","toChecksumAddress","sha256","getHash","ZERO_ADDRESS","GASLIMIT_DEFAULT","signText","publicKey","password","isMetaMask","currentProvider","personal","sign","e2","signHash","address","signedMessage","substr","r","slice","s","v","signWithHash","hash","utf8ToHex","estApprove","account","tokenAddress","spender","contractInstance","gasLimitDefault","estGas","approve","estimateGas","from","err","force","currentAllowence","allowance","Decimal","greaterThanOrEqualTo","send","gas","gasPrice","trxReceipt","balance","balanceOf","sleep","ms","Promise","resolve","setTimeout","calcMaxExactOut","calcMaxExactIn","getMaxSwapExactOut","poolInstance","poolAddress","getReserve","getMaxSwapExactIn","getMaxAddLiquidity","getMaxRemoveLiquidity","Aquarius","aquariusURL","did","signal","path","json","status","txid","tries","ddo","event","valid","jsonResponse","JSON","stringify","proof","validatorAddress","errors","MaxUint256","Pool","poolAbi","PoolTemplate","abi","fromWei","fee","poolContract","defaultErc20Abi","setSwapFee","pool","estSetSwapFee","getNumTokens","totalSupply","getCurrentTokens","getFinalTokens","getController","getBaseTokenAddress","getDatatokenAddress","getMarketFee","_publishMarketCollector","_opcCollector","isBound","getBalance","isFinalized","getSwapFee","weight","getNormalizedWeight","getDenormalizedWeight","getTotalDenormalizedWeight","publishMarketFees","getCurrentOPCFees","communityFees","collectOPC","estCollectOPC","collectMarketFee","getMarketFeeCollector","estCollectMarketFee","newPublishMarketAddress","newPublishMarketSwapFee","updatePublishMarketFee","estUpdatePublishMarketFee","tokenInOutMarket","amountsInOutMaxFee","tokenAmountIn","tokenIn","minAmountOut","tokenOut","maxPrice","getBaseToken","swapExactAmountIn","maxSwap","greaterThan","estSwapExactAmountIn","maxAmountIn","tokenAmountOut","swapExactAmountOut","estSwapExactAmountOut","poolAmountOut","maxAmountsIn","joinPool","weiMaxAmountsIn","tokens","i","push","estJoinPool","poolAmountIn","minAmountsOut","exitPool","weiMinAmountsOut","estExitPool","minPoolAmountOut","joinswapExternAmountIn","amountInFormatted","estJoinswapExternAmountIn","minTokenAmountOut","exitswapPoolAmountIn","calcSingleOutGivenPoolIn","minTokenOutFormatted","estExitswapPoolAmountIn","decimalsTokenIn","decimalsTokenOut","tokenInContract","tokenOutContract","decimalsDiff","price","getSpotPrice","amountOutFormatted","getAmountInExactOut","tokenAmount","liquidityProviderSwapFeeAmount","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","getAmountOutExactIn","calcPoolOutSingleIn","calcSingleInPoolOut","calcSingleOutPoolIn","calcPoolInSingleOut","getSwapEventSignature","eventdata","o","encodeEventSignature","getJoinEventSignature","getExitEventSignature","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","maxTokens","maxBalance","logger","dtAddress","allowedSwapper","create","estGasCreate","activate","estGasActivate","deactivate","estGasDeactivate","newAllowedSwapper","setAllowedSwapper","estGasSetAllowedSwapper","destination","dispense","estGasDispense","ownerWithdraw","estGasOwnerWithdraw","datatoken","active","String","isMinter","FixedRateCreateProgressStep","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","baseToken","generateExchangeId","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","exchange","getExchange","consumeMarketFeeFormatted","dtAmountFormatted","maxBtFormatted","estBuyDT","sellDT","minBaseTokenAmount","minBtFormatted","getNumberOfExchanges","newRate","setRate","estSetRate","estSetAllowedSwapper","toggleExchangeState","estActivate","estDeactivate","weiRate","getRate","dtSupply","getDTSupply","btSupply","getBTSupply","getAllowedSwapper","fixedRateExchange","calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","calcBaseOutGivenInDT","dtDecimals","btDecimals","dtBalance","btBalance","getFeesInfo","opcFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","toggleMintState","estActivateMint","fixedrate","amountWei","collectBT","estCollectBT","collectDT","estCollectDT","estCollectOceanFee","collectOceanFee","opcCollector","router","exchangeOwner","newMarketFee","updateMarketFee","newMarketFeeCollector","updateMarketFeeCollector","estUpdateMarketFeeCollector","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","nftAddress","nftContract","createERC20","getNftPermissions","deployERC20","estGasCreateErc20","events","TokenCreated","returnValues","manager","addManager","getNftOwner","estGasAddManager","removeManager","estGasRemoveManager","erc20Deployer","addToCreateERC20List","estGasAddErc20Deployer","removeFromCreateErc20List","estGasRemoveErc20Deployer","removeFromCreateERC20List","metadataUpdater","addToMetadataList","estGasAddMetadataUpdater","removeFromMetadataList","updateMetadata","esGasRemoveMetadataUpdater","storeUpdater","addTo725StoreList","estGasAddStoreUpdater","removeFrom725StoreList","store","estGasRemoveStoreUpdater","cleanPermissions","estGasCleanPermissions","nftOwner","nftReceiver","tokenId","transferFrom","tokenIdentifier","estGasTransferNft","safeTransferFrom","estGasSafeTransferNft","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","estGasSetMetadata","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","estGasSetMetadataAndTokenURI","setMetaDataState","estGasSetMetadataState","setTokenURI","estSetTokenURI","ownerOf","getPermissions","getMetaData","isERC20Deployer","key","id","tokenURI","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","dtContract","estGasApprove","toAddress","mint","fixedRateParams","createFixedRate","estGasCreateFixedRate","dispenserParams","createDispenser","estGasCreateDispenser","getDTPermissions","capAvailble","getCap","gte","estGasMint","addMinter","estGasAddMinter","removeMinter","estGasRemoveMinter","paymentManager","addPaymentManager","estGasAddPaymentManager","removePaymentManager","estGasRemovePaymentManager","setPaymentCollector","isPaymentManager","getNFTAddress","isNftOwner","nftPermissions","estGasSetPaymentCollector","getPaymentCollector","weiAmount","transferWei","transfer","estGasTransfer","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","publishMarketFee","getPublishingMarketFee","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","getCurrentAllownceTokens","currentAllowance","_this","all","estGasStartOrder","orderParams","buyFromFreAndOrder","freContractParams","estGasBuyFromFreAndOrder","buyFromDispenserAndOrder","estGasBuyFromDispenserAndOrder","value","setData","estGasSetData","permissions","getERC721Address","addressZERO","NftFactory","factory721","defaultFactory721Abi","nftData","deployERC721Contract","transferable","getCurrentNFTTemplateCount","getNFTTemplate","estGasCreateNFT","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTemplateCount","getTokenTemplate","erc20List","erc721List","templateAddress","add721TokenTemplate","getOwner","estGasAddNFTTemplate","disable721TokenTemplate","estGasDisableNFTTemplate","reactivate721TokenTemplate","estGasReactivateNFTTemplate","addTokenTemplate","estGasAddTokenTemplate","disableTokenTemplate","getCurrentTokenTemplateCount","estGasDisableTokenTemplate","reactivateTokenTemplate","estGasReactivateTokenTemplate","orders","startMultipleTokenOrder","estGasStartMultipleTokenOrder","nftCreateData","ercCreateData","createNftWithErc20","estGasCreateNftWithErc20","poolData","createNftWithErc20WithPool","estGasCreateNftErc20WithPool","fixedData","createNftWithErc20WithFixedRate","estGasCreateNftErc20WithFixedRate","createNftWithErc20WithDispenser","estGasCreateNftErc20WithDispenser","Config","providerAddress","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","noZeroX","input","zeroOutput","output","regexp","conversorName","inputMatch","zeroXTransformer","Provider","endpoints","getEndpointURL","servicesEndpoints","serviceName","providerEndpoint","serviceEndpoints","urlPath","consumerAddress","providerEndpoints","getEndpoints","getServiceEndpoints","nonce","accountId","agreementId","serviceId","files","results","_this$getEndpointURL","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","transferTxId","downloadUrl","Date","now","consumeUrl","createSignature","dataset","algorithm","additionalDatasets","computeStartUrl","signatureMessage","documentId","signature","createHashSignature","Object","environment","statusText","jobId","computeStopUrl","getNonce","computeStatusUrl","computeResultUrl","resultUrl","computeDeleteUrl","params","ProviderInstance"],"mappings":"87BACYA,IAAAA,GAAZ,SAAYA,GACVA,oBACAA,qBACAA,mBACAA,iBACAA,yBALF,CAAYA,IAAAA,aASCC,EACXC,YAAoBC,EAAqBH,EAASI,YAA9BD,gBAAAE,cAAAF,EAEbG,SAASH,GACdE,KAAKF,SAAWA,EAGXI,UAAUC,GACfH,KAAKI,SAAS,OAAQC,YAAoBF,GAGrCG,SAASH,GACdH,KAAKI,SAAS,QAAST,EAASY,WAAYJ,GAGvCK,OAAOL,GACZH,KAAKI,SAAS,MAAOT,EAASc,OAAQN,GAGjCO,QAAQP,GACbH,KAAKI,SAAS,OAAQT,EAASgB,QAASR,GAGnCS,SAAST,GACdH,KAAKI,SAAS,QAAST,EAASI,SAAUI,GAGpCC,SAASS,EAAcC,KAAoBX,GAC7CH,KAAKF,UAAYgB,GACnBC,QAAQF,MAASV,IAKVa,MAAAA,EAAiB,IAAIpB,+qECtClBqB,EAAeC,GAI7B,MAAMC,EAAOD,GAAYE,EACnBC,EAAUC,KAAKC,MAAMD,KAAKE,SAAWL,EAAKM,WAAWC,QACrDC,EAAUL,KAAKC,MAAMD,KAAKE,SAAWL,EAAKS,MAAMF,QAChDG,EAAcP,KAAKC,MAAsB,IAAhBD,KAAKE,UAG9BM,EAAYX,EAAKM,WAAWJ,GAASU,QAAQ,MAAQC,GAAMA,EAAEC,eAC7DC,EAAOf,EAAKS,MAAMD,GAASI,QAAQ,MAAQC,GAAMA,EAAEC,eAQzD,MAAO,CAAEE,QANOL,KAAaI,UAMdE,WAHbN,EAAUO,UAAU,EAAG,GAAKH,EAAKG,UAAU,EAAG,IAC9CJ,iBAAiBJ,WCrBRS,EAAS,CACpB,CACEC,UAAU,EACVC,OAAQ,GACRL,KAAM,OACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,WAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEL,KAAM,WACNO,KAAM,WAER,CACEP,KAAM,SACNO,KAAM,YAGVP,KAAM,UACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRL,KAAM,cACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEL,KAAM,QACNO,KAAM,WAER,CACEP,KAAM,MACNO,KAAM,WAER,CACEP,KAAM,SACNO,KAAM,YAGVP,KAAM,eACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRL,KAAM,WACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,UAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEL,KAAM,SACNO,KAAM,YAGVP,KAAM,YACNM,QAAS,CACP,CACEN,KAAM,UACNO,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRL,KAAM,SACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,WAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEL,KAAM,MACNO,KAAM,WAER,CACEP,KAAM,SACNO,KAAM,YAGVP,KAAM,WACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEL,KAAM,SACNO,KAAM,WAER,CACEP,KAAM,WACNO,KAAM,YAGVP,KAAM,YACNM,QAAS,CACP,CACEN,KAAM,GACNO,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEC,SAAS,EACTC,gBAAiB,UACjBF,KAAM,YAER,CACEG,WAAW,EACXL,OAAQ,CACN,CACEM,SAAS,EACTX,KAAM,QACNO,KAAM,WAER,CACEI,SAAS,EACTX,KAAM,UACNO,KAAM,WAER,CACEI,SAAS,EACTX,KAAM,QACNO,KAAM,YAGVP,KAAM,WACNO,KAAM,SAER,CACEG,WAAW,EACXL,OAAQ,CACN,CACEM,SAAS,EACTX,KAAM,OACNO,KAAM,WAER,CACEI,SAAS,EACTX,KAAM,KACNO,KAAM,WAER,CACEI,SAAS,EACTX,KAAM,QACNO,KAAM,YAGVP,KAAM,WACNO,KAAM,mBC/MMK,EAAoBC,EAAoBC,GAqBtD,OApBIA,IACEA,EAAOC,0BACTF,EAASE,wBAA0BD,EAAOC,yBACxCD,EAAOE,gCACTH,EAASG,8BAAgCF,EAAOE,+BAC9CF,EAAOG,4BACTJ,EAASI,0BAA4BH,EAAOG,4BAEhDrC,QAAQP,IACN,mBACAyC,EAAOC,wBACPD,EAAOE,8BACPF,EAAOG,2BAETrC,QAAQP,IACN,kBACAwC,EAASE,wBACTF,EAASG,8BACTH,EAASI,2BAEJJ,iBAGaK,EAAgBC,EAAYL,GAChD,MAAMM,EAAI,IAAIC,QAAgBF,EAAKG,IAAIC,eAEvC,OADA3C,QAAQP,IAAI,yBAAoByC,SAAAA,EAAQU,kBACpCV,GAAUA,EAAOU,iBACZJ,EACJK,aAAaX,EAAOU,kBACpBE,aAAaL,EAAUM,YACvBC,SAAS,IACFR,EAAEQ,SAAS,aAGTC,EAAqBC,GACnC,IAAI9B,EAAcC,EAKlB,OAHK6B,EAAU9B,MAAS8B,EAAU7B,UAC5BD,KAAAA,EAAMC,OAAAA,GAAWnB,KAEhB,CACLiD,cAAeD,EAAUC,cACzBC,QAAS,CAACF,EAAU9B,MAAQA,EAAM8B,EAAU7B,QAAUA,GACtDgC,UAAW,CACTH,EAAUI,OACVJ,EAAUK,iBACVL,EAAUM,aACVN,EAAUO,UAEZC,MAAO,CAACC,EAAKC,MAAMC,MAAMX,EAAUY,KAAMH,EAAKC,MAAMC,MAAMX,EAAUa,YACpEC,OAAQ,aAIIC,EAAkBC,GAChC,MAAO,CACLC,iBAAkBD,EAAUC,iBAC5BC,WAAYF,EAAUE,WACtBC,mBAAoBV,EAAKC,MAAMC,MAAMK,EAAUG,oBAC/CC,cAAeX,EAAKC,MAAMC,MAAMK,EAAUI,eAC1CC,iBAAkBL,EAAUK,2BAIhBC,EAAqBN,GAC9BA,EAAUO,kBACbP,EAAUO,gBAAkB,8CAC9B,MAAMC,EAAWR,EAAUQ,SAAW,EAAI,EAE1C,MAAO,CACLC,kBAAmBT,EAAUU,iBAC7BvB,UAAW,CACTa,EAAUW,iBACVX,EAAUY,MACVZ,EAAUa,mBACVb,EAAUO,iBAEZf,MAAO,CACLQ,EAAUc,kBACVd,EAAUe,kBACVtB,EAAKC,MAAMC,MAAMK,EAAUgB,WAC3BvB,EAAKC,MAAMC,MAAMK,EAAUiB,WAC3BT,mBAKgBU,EACpB7C,EACA8C,GAEA,MAAO,CACLhC,UAAW,CACTgC,EAAWC,WACXD,EAAWR,iBACXQ,EAAWE,gBACXF,EAAWG,iBACXH,EAAWN,mBACXM,EAAWI,qBAEbC,SAAU,CACR/B,EAAKC,MAAMC,MAAMwB,EAAWM,MAC5BN,EAAWL,kBACXrB,EAAKC,MAAMC,MAAMwB,EAAWO,eAC5BP,EAAWQ,mBACLC,EACJvD,EACA8C,EAAWR,iBACXQ,EAAWU,4BAGfC,SAAU,CACRrC,EAAKC,MAAMC,MAAMwB,EAAWY,0BAC5BtC,EAAKC,MAAMC,MAAMwB,EAAWa,sCAIZC,EACpB5D,EACA6D,EACAC,GAEA,IACE,MAAMC,EAAgB,IAAI/D,EAAKG,IAAI6D,SAAShF,EAAQ6E,GACpD,IAAII,QAAiBF,EAAcG,QAAQD,WAAWE,OACrC,MAAbF,IACFA,EAAW,IAGb,MAAMG,EAAkB,IAAIlE,EAAU4D,GAAQO,IAC5C,IAAInE,EAAU,IAAIoE,gBAAgBL,IAIpC,OADA/D,EAAUP,OAAO,CAAE4E,eAAgB,KAC5BH,EAAgB3D,WACvB,MAAO+D,GACP9G,EAAeJ,uDAAuDkH,EAAEC,2BAItDlB,EACpBvD,EACA6D,EACAC,GAEA,IACE,MAAMC,EAAgB,IAAI/D,EAAKG,IAAI6D,SAAShF,EAAQ6E,GACpD,IAAII,QAAiBF,EAAcG,QAAQD,WAAWE,OAUtD,MATiB,MAAbF,IACFA,EAAW,IAEb/D,EAAUP,OAAO,CAAE4E,eAAgB,KAEX,IAAIrE,EAAU4D,GAAQY,MAC5C,IAAIxE,EAAU,IAAIoE,gBAAgBL,IAGbxD,WACvB,MAAO+D,GACP9G,EAAeJ,sDAAsDkH,EAAEC,2BC1KrDE,EAAUC,EAAaC,GAC3C,MAAMC,QAAeC,EAAMH,EAAKC,GAChC,IAAKC,EAAOE,GAGV,MAFAtH,EAAeJ,2BAA2BuH,EAAKI,WAAWL,KAC1DlH,EAAeJ,mCAAmCwH,EAAOI,UACnDJ,EAER,OAAOA,iBAGaK,EAAoBP,GACxC,MAAMQ,EAASC,SAASC,cAAc,KACtCF,EAAOG,SAAW,GAClBH,EAAOI,KAAOZ,EACdQ,EAAOK,uBAGaC,EACpBd,EACAe,GAEA,MAAMC,QAAiBb,EAAMH,GAC7B,IAAKgB,EAASZ,GACZ,UAAUvI,MAAM,mBAElB,IAAIoJ,EACJ,IACEA,EAAWD,EAASE,QACjBC,IAAI,uBACJC,MAAM,4BAA4B,GACrC,SACA,IACEH,EAAWjB,EAAIqB,MAAM,KAAKC,MAC1B,SACAL,SAAkBF,KAItB,MAAO,CAAEQ,WAAYP,EAASQ,cAAeP,SAAAA,kBAGzBQ,EAAQzB,GAC5B,OAAOG,EAAMH,EAAK,CAChBK,OAAQ,MACRa,QAAS,CACP,eAAgB,qCAuBAQ,EAAS1B,EAAa2B,GAI1C,OAtBFC,eACE5B,EACA2B,EACAT,GAEA,OACSf,EAAMH,EADA,MAAX2B,EACgB,CAChBtB,OAAQ,OACRwB,KAAMF,EACNT,QAUY,CACd,eAAgB,qBARE,CAChBb,OAAQ,SASLyB,CAAgB9B,EAAK2B,mNCvE9B,MAAMI,EAAmC,CACvCC,QAAS,KACTC,QAAS,UACTC,iBAAkB,wCAClBC,QAAS,wBACTC,YAAa,wBACbC,YAAa,KACbC,YAAa,KACbC,kBAAmB,KACnBC,iBAAkB,QAClBlE,oBAAqB,KACrBmE,yBAA0B,KAC1BC,iBAAkB,KAClBC,WAAY,EACZ3H,wBAAyB,GACzBC,8BAA+B,EAC/BC,0BAA2B,IAC3BO,iBAAkB,GAGPmH,EAAiC,MAEvCb,QAIAA,GACHC,QAAS,KACTC,QAAS,cACTC,iBAAkB,+BAGfH,GACHC,QAAS,EACTC,QAAS,UACTE,QAAS,+BACTC,YAAa,gDACbC,YAAa,gDACbC,YAAa,+BACb7G,iBAAkB,WAGfsG,GACHC,QAAS,EACTC,QAAS,UACTE,QAAS,+BACTC,YAAa,gDACbC,YAAa,gDACbC,YAAa,+BACb7G,iBAAkB,WAGfsG,GACHC,QAAS,EACTC,QAAS,UACTE,QAAS,+BACTC,YAAa,gDACbC,YAAa,gDACbC,YAAa,uBACbK,WAAY,SACZ3H,wBAAyB,IACzBC,8BAA+B,EAC/BC,0BAA2B,KAC3BO,iBAAkB,YAGfsG,GACHC,QAAS,IACTC,QAAS,UACTE,QAAS,uCACTC,YAAa,gDACbC,YAAa,gDACbC,YAAa,0BACbE,iBAAkB,gBAGfT,GACHC,QAAS,KACTC,QAAS,WACTE,QAAS,4CACTC,YAAa,iDACbC,YAAa,iDACbC,YAAa,gCACb7G,iBAAkB,WAGfsG,GACHC,QAAS,OACTC,QAAS,eACTE,QAAS,6CACTC,YAAa,qDACbC,YAAa,qDACbC,YAAa,2DAGVP,GACHC,QAAS,MACTC,QAAS,SACTE,QAAS,sCACTC,YAAa,+CACbC,YAAa,+CACbC,YAAa,iCACb7G,iBAAkB,WAGfsG,GACHC,QAAS,GACTC,QAAS,MACTE,QAAS,mCACTC,YAAa,4CACbC,YAAa,4CACbC,YAAa,uBACb7G,iBAAkB,YAGfsG,GACHC,QAAS,IACTC,QAAS,YACTE,QAAS,4BACTC,YAAa,kDACbC,YAAa,kDACbC,YAAa,iCACb7G,iBAAkB,YAGfsG,GACHC,QAAS,KACTC,QAAS,YACTE,QAAS,6CACTC,YAAa,kDACbC,YAAa,kDACbC,YAAa,iCACb7G,iBAAkB,cAIToH,EAEJC,oBAAoBb,EAAiBc,GAE1C,IAAIC,EAGJ,GAAID,EACF,IACE,MAAME,WACJA,EADIC,UAEJA,EAFIC,QAGJA,EAHIC,aAIJA,EAJIC,cAKJA,EALIC,yBAMJA,EANIC,MAOJA,EAPIvB,QAQJA,EARIW,WASJA,GACEI,EAAgBd,GACpBe,KACEQ,qBAAsBH,EACtBI,mBAAoBN,EACpBO,yBAA0BJ,EAC1BhF,oBAAqB8E,EACrBX,yBAA0BQ,EAC1BP,iBAAkBQ,EAClBX,kBAAmBgB,EACnBvB,QAASA,EACTW,WAAYA,GACRgB,QAAQC,IAAIC,cAAgB,CAAE3B,iBAAkByB,QAAQC,IAAIC,eAElE,MAAOjE,SAMT,GAAIkE,EAA0B7B,GAAU,CACtC,MAAMgB,WACJA,EADIC,UAEJA,EAFIC,QAGJA,EAHIC,aAIJA,EAJIE,yBAKJA,EALID,cAMJA,EANIE,MAOJA,EAPIvB,QAQJA,EARIW,WASJA,GACEmB,EAA0B7B,GAC9Be,KACEQ,qBAAsBH,EACtBI,mBAAoBN,EACpBO,yBAA0BJ,EAC1BhF,oBAAqB8E,EACrBX,yBAA0BQ,EAC1BP,iBAAkBQ,EAClBX,kBAAmBgB,EACnBvB,QAASA,EACTW,WAAYA,GACRgB,QAAQC,IAAIC,cAAgB,CAAE3B,iBAAkByB,QAAQC,IAAIC,eAItE,OAAOb,EAGFe,UAAU9B,EAA0B+B,GACzC,MAAMC,EAA8B,iBAAZhC,EAAuB,UAAY,UAC3D,IAAIlH,EAAS6H,EAAqBsB,KAAMpK,GAAMA,EAAEmK,KAAchC,GAE9D,OAAKlH,GAMLA,OAAcA,EADkBjD,KAAKgL,oBAAoB/H,EAAOkH,eAOpDlH,GAAQoH,QAJJ6B,KACTjJ,EAAOoH,WAAW6B,IACrBjJ,EAAOoH,YATTrJ,EAAeJ,4CAA4CuJ,sBCjNjDkC,EAAYC,EAAuBpC,GAGjD,OAFAoC,EAAgB5H,EAAKC,MAAM4H,kBAAkBD,aAC5BE,EAAOF,EAAgBpC,EAAQnG,SAAS,KAC/BA,sBAGZ0I,EAAQhD,GACtB,IACE,OAAO+C,EAAO/C,GAAM1F,WACpB,MAAO+D,GACP9G,EAAeJ,MAAM,kBAAmBkH,EAAEC,UCdjC2E,MAAAA,EAAe,6CACfC,EAAmB,mBCEVC,EACpBtJ,EACAkF,EACAqE,EACAC,GAEA,MAAMC,EACJzJ,GAAQA,EAAK0J,iBAAoB1J,EAAK0J,gBAAwBD,WAChE,IACE,aAAazJ,EAAKG,IAAIwJ,SAASC,KAAK1E,EAAMqE,EAAWC,GACrD,MAAOhF,GACP,GAAIiF,EACF,MAAMjF,EAER9G,EAAeN,KAAK,2BACpBM,EAAeN,KAAKoH,GACpB,IACE,aAAaxE,EAAKG,IAAIyJ,KAAK1E,EAAMqE,GACjC,MAAOM,GAGP,MAFAnM,EAAeJ,MAAM,kBACrBI,EAAeJ,MAAMuM,OACXpN,MAAM,kDAKAqN,EAAS9J,EAAYyE,EAAiBsF,GAC1D,IAAIC,QAAsBhK,EAAKG,IAAIyJ,KAAKnF,EAASsF,GACjDC,EAAgBA,EAAcC,OAAO,GACrC,MAAMC,EAAI,KAAOF,EAAcG,MAAM,EAAG,IAClCC,EAAI,KAAOJ,EAAcG,MAAM,GAAI,KACzC,IAAIE,EAAI,KAAOL,EAAcG,MAAM,IAAK,KAIxC,MAFU,SAANE,IAAcA,EAAI,QACZ,SAANA,IAAcA,EAAI,QACf,CAAEA,EAAAA,EAAGH,EAAAA,EAAGE,EAAAA,kBAGKE,EACpBtK,EACAkF,EACAqE,EACAC,GAEA,MAAMe,EAAOvK,EAAKqB,MAAMmJ,UAAUtF,GAC5BuE,EACJzJ,GAAQA,EAAK0J,iBAAoB1J,EAAK0J,gBAAwBD,WAChE,IACE,aAAazJ,EAAKG,IAAIwJ,SAASC,KAAKW,EAAMhB,EAAWC,GACrD,MAAOhF,GACP,GAAIiF,EACF,MAAMjF,EAER9G,EAAeN,KAAK,2BACpBM,EAAeN,KAAKoH,GACpB,IACE,aAAaxE,EAAKG,IAAIyJ,KAAKW,EAAMhB,GACjC,MAAOM,GAGP,MAFAnM,EAAeJ,MAAM,kBACrBI,EAAeJ,MAAMuM,OACXpN,MAAM,kDC5CAgO,EACpBzK,EACA0K,EACAC,EACAC,EACA9G,EACA+G,GAEA,MAAM9G,EAAgB8G,GAAoB,IAAI7K,EAAKG,IAAI6D,SAAShF,EAAQ2L,GAElEG,EF5BwB,IE6B9B,IAAIC,EACJ,IACEA,QAAehH,EAAcG,QAC1B8G,QAAQJ,EAAS9G,GACjBmH,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EACTpN,EAAeJ,MAAM,mCAAoCkH,GAE3D,OAAOuG,iBAWaC,EACpBhL,EACA0K,EACAC,EACAC,EACA9G,EACAsH,GAAQ,GAER,MAAMrH,EAAgB,IAAI/D,EAAKG,IAAI6D,SAAShF,EAAQ2L,GACpD,IAAKS,EAAO,CACV,MAAMC,QAAyBC,EAAUtL,EAAM2K,EAAcD,EAASE,GACtE,GAAI,IAAIW,EAAQF,GAAkBG,qBAAqB,IAAID,EAAQzH,IACjE,OAAOuH,EAGX,IAAIvG,EAAS,KACb,MAAMV,QAAwBb,EAAcvD,EAAM2K,EAAc7G,GAC1DiH,QAAeN,EACnBzK,EACA0K,EACAC,EACAC,EACAxG,EACAL,GAGF,IACEe,QAAef,EAAcG,QAAQ8G,QAAQJ,EAASxG,GAAiBqH,KAAK,CAC1EP,KAAMR,EACNgB,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBC,EAAM,QAExC,MAAOwE,GACP9G,EAAeJ,4DACyCkH,EAAEC,WAG5D,OAAOK,iBAUawG,EACpBtL,EACA2K,EACAD,EACAE,GAEA,MAAM7G,EAAgB,IAAI/D,EAAKG,IAAI6D,SAAShF,EAAQ2L,GAC9CiB,QAAmB7H,EAAcG,QAAQoH,UAAUZ,EAASE,GAASzG,OAE3E,aAAaP,EAAc5D,EAAM2K,EAAciB,kBAU3BC,EACpB7L,EACA2K,EACAD,GAEA,MAAM3G,EAAgB,IAAI/D,EAAKG,IAAI6D,SAAShF,EAAQ2L,GAC9CiB,QAAmB7H,EAAcG,QAAQ4H,UAAUpB,GAASvG,OAElE,aAAaP,EAAc5D,EAAM2K,EAAciB,kBCzH3BG,EAAMC,GAC1B,WAAWC,QAASC,IAClBC,WAAWD,EAASF,cCFRI,EAAgBP,GAC9B,WAAWN,EAAQM,GAASxH,IAAI,eAGlBgI,EAAeR,GAC7B,WAAWN,EAAQM,GAASxH,IAAI,qBAEZiI,EACpBC,EACAC,EACA7B,GAGA,OAAOyB,QADeG,EAAaE,WAAWD,EAAa7B,mBAIvC+B,EACpBH,EACAC,EACA7B,GAGA,OAAO0B,QADeE,EAAaE,WAAWD,EAAa7B,mBAIvCgC,EACpBJ,EACAC,EACA7B,GAIA,OAAO0B,QAFeE,EAAaE,WAAWD,EAAa7B,mBAKvCiC,EACpBL,EACAC,EACA7B,GAIA,OAAO0B,QAFeE,EAAaE,WAAWD,EAAa7B,UCxChDkC,GAMXtQ,YAAYuQ,QALLA,mBAMLpQ,KAAKoQ,YAAcA,EAQDtG,cAACuG,EAAaC,GAChC,MAAMC,EAAOvQ,KAAKoQ,YAAc,4BAA8BC,EAC9D,IACE,MAAMnH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,GAAIpH,EAASZ,GAEX,aADkBY,EAASsH,OAG3B,UAAUzQ,MAAM,mCAAqCmJ,EAASuH,QAEhE,MAAO3I,GAEP,MADA9G,EAAeJ,MAAMkH,OACX/H,MAAM,wBAYI+J,kBACtBuG,EACAK,EACAJ,GAEA,IAAIK,EAAQ,EACZ,EAAG,CACD,IACE,MAAMJ,EAAOvQ,KAAKoQ,YAAc,4BAA8BC,EACxDnH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEV,GAAIpH,EAASZ,GAAI,CACf,MAAMsI,QAAY1H,EAASsH,OAC3B,IAAIE,SAGUE,EADZ,GAAIA,EAAIC,OAASD,EAAIC,MAAMH,OAASA,EAAM,OAAOE,GAGrD,MAAO9I,UAGHuH,EAAM,MACZsB,UACOA,EAAQ,KACjB,YASmB7G,eAAC8G,EAAUN,GAC9B,MAAMG,EAA2B,CAC/BK,OAAO,GAET,IAAIC,EACJ,IACE,MAAMR,EAAOvQ,KAAKoQ,YAAc,oCAE1BlH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,OACRwB,KAAMiH,KAAKC,UAAUL,GACrBxH,QAAS,CACP,eAAgB,4BAElBkH,OAAQA,IAGVS,QAAqB7H,EAASsH,OACN,MAApBtH,EAASuH,QACXA,EAAOK,OAAQ,EACfL,EAAO5C,KAAOkD,EAAalD,KAC3B4C,EAAOS,MAAQ,CACbC,iBAAkBJ,EAAalE,UAC/BW,EAAGuD,EAAavD,EAAE,GAClBE,EAAGqD,EAAarD,EAAE,GAClBC,EAAGoD,EAAapD,KAGlB8C,EAAOW,OAASL,EAChB/P,EAAeJ,MAAM,4BAA6BsI,EAASuH,OAAQA,EAAOW,SAE5E,MAAOxQ,GACPI,EAAeJ,MAAM,8BAA+BA,GAEtD,OAAO6P,GC3FX,MAAMY,GACJ,uFAKWC,GAMXzR,YAAYyD,EAAYiO,EAA+B,KAAMtO,QALtDsO,oBACAjO,iBACAqJ,iBAAmB,SAClB1J,cAGOjD,KAAKuR,QAAdA,GACgBC,EAAaC,IACjCzR,KAAKsD,KAAOA,EACZtD,KAAKiD,OAASA,GAAU6H,EAAqB,GAS5BhB,oBAACkE,EAAiB8B,GACnC,IAAI1H,EAAS,KACb,IACE,MAAMjB,EAAQpE,EACZ,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEDkM,QAAgBhI,EAAMK,QAAQ4H,UAAUpB,GAASvG,OACvDW,EAASpI,KAAKsD,KAAKqB,MAAM+M,QAAQvC,GACjC,MAAOrH,GACP9G,EAAeJ,+CAA+CkH,EAAEC,WAElE,OAAOK,EAaiB0B,oBACxBkE,EACA8B,EACA6B,EACAxD,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAASuK,EAAgBJ,IAAkB3B,GAC7D9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzBsK,WAAWH,GACXpD,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASOvE,iBACdkE,EACA8B,EACA6B,GAEA,MAAMI,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,EAAa,CACpDtB,KAAMR,IAERhO,KAAKiD,QAEP,IAAImF,EAAS,KACb,MAAMiG,aAAoB2D,cAAchE,EAAS8B,EAAa6B,GAE9D,IACEvJ,QAAe2J,EAAKvK,QAAQsK,WAAW9R,KAAKsD,KAAKqB,MAAMC,MAAM+M,IAAM5C,KAAK,CACtEP,KAAMR,EACNgB,IAAKX,EACLY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAElD,MAAO6E,GACP9G,EAAeJ,6CAA6CkH,EAAEC,WAEhE,OAAOK,EAQS0B,mBAACgG,GACjB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQyK,eAAexK,OAC3C,MAAOK,GACP9G,EAAeJ,gDAAgDkH,EAAEC,WAEnE,OAAOK,EAQqB0B,+BAACgG,GAC7B,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImE,EAAS,KACb,IACE,MAAMgB,QAAe2J,EAAKvK,QAAQ0K,cAAczK,OAChDL,EAASpH,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,GACjC,MAAON,GACP9G,EAAeJ,2DACwCkH,EAAEC,WAG3D,OAAOX,EASa0C,uBAACgG,GACrB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQ2K,mBAAmB1K,OAC/C,MAAOK,GACP9G,EAAeJ,0DACuCkH,EAAEC,WAG1D,OAAOK,EASW0B,qBAACgG,GACnB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQ4K,iBAAiB3K,OAC7C,MAAOK,GACP9G,EAAeJ,mEACgDkH,EAAEC,WAGnE,OAAOK,EAQU0B,oBAACgG,GAClB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQ6K,gBAAgB5K,OAC5C,MAAOK,GACP9G,EAAeJ,uDAAuDkH,EAAEC,WAE1E,OAAOK,EAQS0B,mBAACgG,GACjB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQ8K,sBAAsB7K,OAClD,MAAOK,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAEpE,OAAOK,EAQS0B,mBAACgG,GACjB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQ+K,sBAAsB9K,OAClD,MAAOK,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAEpE,OAAOK,EAQS0B,mBAACgG,GACjB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQgL,eAAe/K,OAC3C,MAAOK,GACP9G,EAAeJ,4CAA4CkH,EAAEC,WAE/D,YAAYzE,KAAKqB,MAAM+M,QAAQtJ,GAAQrE,WAQd+F,4BAACgG,GAC1B,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQiL,0BAA0BhL,OACtD,MAAOK,GACP9G,EAAeJ,0DACuCkH,EAAEC,WAG1D,OAAOK,EAQY0B,sBAACgG,GACpB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQkL,gBAAgBjL,OAC5C,MAAOK,GACP9G,EAAeJ,qDAAqDkH,EAAEC,WAExE,OAAOK,EAUI0B,cAACgG,EAAqB3I,GACjC,MAAM4K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQmL,QAAQxL,GAAOM,OAC3C,MAAOK,GACP9G,EAAeJ,yEACMkH,EAAEC,WAEzB,OAAOK,EASO0B,iBAACgG,EAAqB3I,GACpC,IAAIC,EAAS,KACb,IACE,MAAM2K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEDmF,QAAe2J,EAAKvK,QAAQoL,WAAWzL,GAAOM,OACpDL,QAAeF,EAAclH,KAAKsD,KAAM6D,EAAOiB,GAC/C,MAAON,GACP9G,EAAeJ,qEACIkH,EAAEC,WAEvB,OAAOX,EAAOrD,WASC+F,kBAACgG,GAChB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,IACEA,QAAe2J,EAAKvK,QAAQqL,cAAcpL,OAC1C,MAAOK,GACP9G,EAAeJ,2DACwCkH,EAAEC,WAG3D,OAAOK,EAQO0B,iBAACgG,GACf,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI0O,EAAM,KACV,IACE,MAAMvJ,QAAe2J,EAAKvK,QAAQsL,aAAarL,OAC/CkK,EAAM3R,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,GAC9B,MAAON,GACP9G,EAAeJ,wCAAwCkH,EAAEC,WAE3D,OAAO4J,EAWgB7H,0BAACgG,EAAqB3I,GAC7C,MAAM4K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI8P,EAAS,KACb,IACE,MAAM3K,QAAe2J,EAAKvK,QAAQwL,oBAAoB7L,GAAOM,OAC7DsL,EAAS/S,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,GACjC,MAAON,GACP9G,EAAeJ,4DACyCkH,EAAEC,WAG5D,OAAOgL,EASkBjJ,4BAACgG,EAAqB3I,GAC/C,MAAM4K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI8P,EAAS,KACb,IACE,MAAM3K,QAAe2J,EAAKvK,QAAQyL,sBAAsB9L,GAAOM,OAC/DsL,EAAS/S,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,GACjC,MAAON,GACP9G,EAAeJ,qEACkDkH,EAAEC,WAGrE,OAAOgL,EASuBjJ,iCAACgG,GAC/B,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI8P,EAAS,KACb,IACE,MAAM3K,QAAe2J,EAAKvK,QAAQ0L,6BAA6BzL,OAC/DsL,EAAS/S,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,GACjC,MAAON,GACP9G,EAAeJ,gEAC6CkH,EAAEC,WAGhE,OAAOgL,EAUUjJ,oBAACgG,EAAqB3I,GACvC,MAAM4K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI8P,EAAS,KACb,IACE,MAAM3K,QAAe2J,EAAKvK,QAAQ2L,kBAAkBhM,GAAOM,OAC3DsL,QAAe7L,EAAclH,KAAKsD,KAAM6D,EAAOiB,GAC/C,MAAON,GACP9G,EAAeJ,uDAAuDkH,EAAEC,WAE1E,OAAOgL,EAOiBjJ,2BAACgG,GACzB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAEE,aADgC8O,EAAKvK,QAAQ4L,oBAAoB3L,OAEjE,MAAOK,GACP9G,EAAeJ,0DACuCkH,EAAEC,YASrC+B,wBAACgG,GACtB,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAEE,aADgC8O,EAAKvK,QAAQ4L,oBAAoB3L,OAEjE,MAAOK,GACP9G,EAAeJ,0DACuCkH,EAAEC,YAWtC+B,uBAACgG,EAAqB3I,GAC1C,MAAM4K,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAI8P,EAAS,KACb,IACE,MAAM3K,QAAe2J,EAAKvK,QAAQ6L,cAAclM,GAAOM,OACvDsL,QAAe7L,EAAclH,KAAKsD,KAAM6D,EAAOiB,GAC/C,MAAON,GACP9G,EAAeJ,0DACuCkH,EAAEC,WAG1D,OAAOgL,EAUiBjJ,oBACxBuD,EACAyC,EACA3B,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzB8L,aACA/E,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASOvE,iBAACuD,EAAiByC,GAChC,MAAMiC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,MAAMiG,aAAoBkF,cAAclG,EAASyC,GAEjD,IACE1H,QAAe2J,EAAKvK,QAAQ8L,aAAavE,KAAK,CAC5CP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAElD,MAAO6E,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAEpE,OAAOK,EAWuB0B,0BAC9BuD,EACAyC,EACA3B,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzBgM,mBACAjF,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUavE,uBACpBuD,EACAyC,GAEA,cAAgB2D,sBAAsB3D,KAAkBzC,EACtD,UAAUtN,0CAEZ,MAAMgS,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,MAAMiG,aAAoBqF,oBAAoBrG,EAASyC,GAEvD,IACE1H,QAAe2J,EAAKvK,QAAQgM,mBAAmBzE,KAAK,CAClDP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAElD,MAAO6E,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAEpE,OAAOK,EAY6B0B,gCACpCuD,EACAyC,EACA6D,EACAC,EACAzF,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzBqM,uBAAuBF,EAAyBC,GAChDrF,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWmBvE,6BAC1BuD,EACAyC,EACA6D,EACAC,GAEA,cAAgBH,sBAAsB3D,KAAkBzC,EACtD,UAAUtN,0CAEZ,MAAMgS,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KAEb,MAAMiG,aAAoByF,0BACxBzG,EACAyC,EACA6D,EACA3T,KAAKsD,KAAKqB,MAAMC,MAAMgP,IAExB,IACExL,QAAe2J,EAAKvK,QACjBqM,uBACCF,EACA3T,KAAKsD,KAAKqB,MAAMC,MAAMgP,IAEvB7E,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,mDAAmDkH,EAAEC,WAEtE,OAAOK,EAYwB0B,2BAC/BuD,EACAyC,EACAiE,EACAC,EACA7F,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHgR,QAAsBpN,EAC1B7G,KAAKsD,KACLyQ,EAAiBG,QACjBF,EAAmBC,eAGfE,QAAqBtN,EACzB7G,KAAKsD,KACLyQ,EAAiBK,SACjBJ,EAAmBG,cAGfE,EAAWL,EAAmBK,SAChCxN,EACE7G,KAAKsD,gBACMgR,aAAaxE,GACxBkE,EAAmBK,UAErBhD,GAEEjD,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzB+M,kBACC,CACER,EAAiBG,QACjBH,EAAiBK,SACjBL,EAAiBzO,kBAEnB,CACE2O,EACAE,EACAE,EACArU,KAAKsD,KAAKqB,MAAMC,MAAMoP,EAAmB3O,iBAG5CkJ,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAgBcvE,wBACrBuD,EACAyC,EACAiE,EACAC,GAEA,MAAMjC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAGDuR,QAAgBxE,EAAkBhQ,KAAM8P,EAAaiE,EAAiBG,SAC5E,GAAI,IAAIrF,EAAQmF,EAAmBC,eAAeQ,YAAYD,GAC5D,UAAUzU,uCAAuCyU,EAAQzQ,cAG3D,MAAMsK,aAAoBqG,qBACxBrH,EACAyC,EACAiE,EACAC,GAGIC,QAAsBpN,EAC1B7G,KAAKsD,KACLyQ,EAAiBG,QACjBF,EAAmBC,eAGfE,QAAqBtN,EACzB7G,KAAKsD,KACLyQ,EAAiBK,SACjBJ,EAAmBG,cAGrB,IAAI/L,EAAS,KAEb,MAAMiM,EAAWL,EAAmBK,eAC1BxN,EACJ7G,KAAKsD,gBACMgR,aAAaxE,GACxBkE,EAAmBK,UAErBhD,GAEJ,IACEjJ,QAAe2J,EAAKvK,QACjB+M,kBACC,CACER,EAAiBG,QACjBH,EAAiBK,SACjBL,EAAiBzO,kBAEnB,CACE2O,EACAE,EACAE,EACArU,KAAKsD,KAAKqB,MAAMC,MAAMoP,EAAmB3O,iBAG5C0J,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAGpE,OAAOK,EAYyB0B,4BAChCuD,EACAyC,EACAiE,EACAC,EACA7F,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAEvBgI,QAAoB9N,EACxB7G,KAAKsD,KACLyQ,EAAiBG,QACjBF,EAAmBW,aAGfC,QAAuB/N,EAC3B7G,KAAKsD,KACLyQ,EAAiBK,SACjBJ,EAAmBY,gBAGfP,EAAWL,EAAmBK,eAC1BxN,EACJ7G,KAAKsD,gBACMgR,aAAaxE,GACxBkE,EAAmBK,UAErBhD,GAEJ,IAAIhD,EACJ,IACEA,QAAeuD,EAAapK,QACzBqN,mBACC,CACEd,EAAiBG,QACjBH,EAAiBK,SACjBL,EAAiBzO,kBAEnB,CACEqP,EACAC,EACAP,EACArU,KAAKsD,KAAKqB,MAAMC,MAAMoP,EAAmB3O,iBAG5CkJ,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWevE,yBACtBkE,EACA8B,EACAiE,EACAC,GAEA,MAAMjC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KAEb,MAAMoM,QAAgB5E,EAAmB5P,KAAM8P,EAAaiE,EAAiBG,SAC7E,GAAI,IAAIrF,EAAQmF,EAAmBY,gBAAgBH,YAAYD,GAC7D,UAAUzU,wCAAwCyU,EAAQzQ,cAG5D,MAAMsK,aAAoByG,sBACxB9G,EACA8B,EACAiE,EACAC,GAGIW,QAAoB9N,EACxB7G,KAAKsD,KACLyQ,EAAiBG,QACjBF,EAAmBW,aAGfC,QAAuB/N,EAC3B7G,KAAKsD,KACLyQ,EAAiBK,SACjBJ,EAAmBY,gBAGfP,EAAWL,EAAmBK,SAChCxN,EACE7G,KAAKsD,gBACMgR,aAAaxE,GACxBkE,EAAmBK,UAErBhD,GAEJ,IACEjJ,QAAe2J,EAAKvK,QACjBqN,mBACC,CACEd,EAAiBG,QACjBH,EAAiBK,SACjBL,EAAiBzO,kBAEnB,CACEqP,EACAC,EACAP,EACArU,KAAKsD,KAAKqB,MAAMC,MAAMoP,EAAmB3O,iBAG5C0J,KAAK,CACJP,KAAMR,EACNgB,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,iDAAiDkH,EAAEC,WAEpE,OAAOK,EAYe0B,kBACtBuD,EACAyC,EACAiF,EACAC,EACA7G,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzByN,SAASF,EAAeC,GACxBzG,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAcKvE,eACZuD,EACAyC,EACAiF,EACAC,GAEA,MAAMjD,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEDiS,EAAkB,GAClBC,aAAoB/C,eAAetC,GAEzC,IAAK,IAAIsF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMhO,QAAeP,EAAc7G,KAAKsD,KAAM6R,EAAOC,GAAIJ,EAAaI,IACtEF,EAAgBG,KAAKjO,GAGvB,IAAIgB,EAAS,KAEb,MAAMiG,aAAoBiH,YACxBjI,EACAyC,EACA9P,KAAKsD,KAAKqB,MAAMC,MAAMmQ,GACtBG,GAGF,IACE9M,QAAe2J,EAAKvK,QACjByN,SAASjV,KAAKsD,KAAKqB,MAAMC,MAAMmQ,GAAgBG,GAC/CnG,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,qCAAqCkH,EAAEC,WAExD,OAAOK,EAYe0B,kBACtBuD,EACAyC,EACAyF,EACAC,EACArH,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzBiO,SAASF,EAAcC,GACvBjH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaKvE,eACZkE,EACA8B,EACAyF,EACAC,GAEA,MAAMzD,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEDyS,EAAmB,GACnBP,aAAoB/C,eAAetC,GAEzC,IAAK,IAAIsF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMhO,QAAeP,EAAc7G,KAAKsD,KAAM6R,EAAOC,GAAII,EAAcJ,IACvEM,EAAiBL,KAAKjO,GAExB,IAAIgB,EAAS,KACb,MAAMiG,aAAoBsH,YACxB3H,EACA8B,EACA9P,KAAKsD,KAAKqB,MAAMC,MAAM2Q,GACtBG,GAGF,IACEtN,QAAe2J,EAAKvK,QACjBiO,SAASzV,KAAKsD,KAAKqB,MAAMC,MAAM2Q,GAAeG,GAC9C3G,KAAK,CACJP,KAAMR,EACNgB,IAAKX,EACLY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,qCAAqCkH,EAAEC,WAExD,OAAOK,EAa6B0B,gCACpCuD,EACAyC,EACAmE,EACA2B,EACAzH,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzBqO,uBAAuB5B,EAAe2B,GACtCrH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAamBvE,6BAC1BkE,EACA8B,EACAmE,EACA2B,GAEA,MAAM7D,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,MAAM8L,aAAqBI,aAAaxE,GAClC0E,QAAgBvE,EAAmBjQ,KAAM8P,EAAaoE,GAC5D,GAAI,IAAIrF,EAAQoF,GAAeQ,YAAYD,GACzC,UAAUzU,wCAAwCyU,EAAQzQ,cAG5D,MAAM+R,QAA0BjP,EAAc7G,KAAKsD,KAAM4Q,EAASD,GAC5D5F,aAAoB0H,0BACxB/H,EACA8B,EACAgG,EACA9V,KAAKsD,KAAKqB,MAAMC,MAAMgR,IAGxB,IACExN,QAAe2J,EAAKvK,QACjBqO,uBACCC,EACA9V,KAAKsD,KAAKqB,MAAMC,MAAMgR,IAEvB7G,KAAK,CACJP,KAAMR,EACNgB,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,sEACEkH,EAAEC,WAErB,OAAOK,EAY2B0B,8BAClCuD,EACAyC,EACAyF,EACAS,EACA7H,GAEA,MAAMyD,EACJzD,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAAsBzB,GACtD9P,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeuD,EAAapK,QACzByO,qBAAqBV,EAAcS,GACnCzH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaiBvE,2BACxBkE,EACA8B,EACAyF,EACAS,GAEA,MAAMjE,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImF,EAAS,KACb,MAAMgM,aAAsBE,aAAaxE,GAEnC8E,aAA4BsB,yBAChCpG,EACAsE,EACAmB,GAGIf,QAAgBtE,EAAsBlQ,KAAM8P,EAAasE,GAC/D,GAAI,IAAIvF,EAAQ+F,GAAgBH,YAAYD,GAC1C,UAAUzU,wCAAwCyU,EAAQzQ,cAG5D,MAAMoS,QAA6BtP,EACjC7G,KAAKsD,gBACMgR,aAAaxE,GACxBkG,GAEI3H,aAAoB+H,wBACxBpI,EACA8B,EACA9P,KAAKsD,KAAKqB,MAAMC,MAAM2Q,GACtBY,GAGF,IACE/N,QAAe2J,EAAKvK,QACjByO,qBAAqBjW,KAAKsD,KAAKqB,MAAMC,MAAM2Q,GAAeY,GAC1DpH,KAAK,CACJP,KAAMR,EACNgB,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAEpD,MAAO6E,GACP9G,EAAeJ,yDAAyDkH,EAAEC,WAE5E,OAAOK,EAWS0B,mBAChBgG,EACAoE,EACAE,EACA/O,GAEA,MAAM0M,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAIoT,EAAkB,GAClBC,EAAmB,GAEvB,MAAMC,EAAkBxT,EACtB,SAASO,KAAKG,IAAI6D,SAASuK,EAAgBJ,IAAkByC,GAC7DlU,KAAKiD,QAEDuT,EAAmBzT,EACvB,SAASO,KAAKG,IAAI6D,SAASuK,EAAgBJ,IAAkB2C,GAC7DpU,KAAKiD,QAEP,IACEoT,QAAwBE,EAAgB/O,QAAQD,WAAWE,OAC3D,MAAOK,GACP9G,EAAeJ,oDAAoDkH,EAAEC,WAEvE,IACEuO,QAAyBE,EAAiBhP,QAAQD,WAAWE,OAC7D,MAAOK,GACP9G,EAAeJ,oDAAoDkH,EAAEC,WAGvE,IAYI0O,EAZAC,EAAQ,KACZ,IACEA,QAAc3E,EAAKvK,QAChBmP,aAAazC,EAASE,EAAUpU,KAAKsD,KAAKqB,MAAMC,MAAMS,IACtDoC,OACHiP,EAAQ,IAAIlT,EAAUkT,EAAM3S,YAC5B,MAAO+D,GACP9G,EAAeJ,MACb,mEAeJ,OAVIyV,EAAkBC,GACpBG,EAAeJ,EAAkBC,EACjCI,EAAQ,IAAIlT,EAAUkT,EAAQ,IAAMD,GACpCC,GAAgB,IAAMJ,IAEtBG,EAAeH,EAAmBD,EAClCK,EAAQ,IAAIlT,EAAUkT,EAAQ,KAAO,EAAID,IACzCC,GAAgB,IAAMJ,GAGjBI,EAAM3S,WAYiB+F,0BAC9BgG,EACAoE,EACAE,EACAQ,EACAvP,GAEA,MAAM0M,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAGDuR,QAAgB5E,EAAmB5P,KAAM8P,EAAaoE,GAE5D,GAAI,IAAIrF,EAAQ+F,GAAgBH,YAAYD,GAC1C,UAAUzU,wCAAwCyU,EAAQzQ,cAG5D,MAAM6S,QAA2B/P,EAAc7G,KAAKsD,KAAM8Q,EAAUQ,GAEpE,IAAIxN,EAAS,KAEb,IACE,MAAMgB,QAAe2J,EAAKvK,QACvBqP,oBACC3C,EACAE,EACAwC,EACA5W,KAAKsD,KAAKqB,MAAMC,MAAMS,IAEvBoC,OACHL,EAAS,CACP0P,kBAAmB5P,EAAclH,KAAKsD,KAAM8Q,EAAUhM,EAAO6L,eAC7D8C,qCAAsC7P,EACpClH,KAAKsD,KACL4Q,EACA9L,EAAO4O,aAETC,qBAAsB/P,EAAclH,KAAKsD,KAAM4Q,EAAS9L,EAAO6O,gBAC/DC,iCAAkChQ,EAChClH,KAAKsD,KACL4Q,EACA9L,EAAO8O,4BAETC,iCAAkCjQ,EAChClH,KAAKsD,KACL4Q,EACA9L,EAAO+O,6BAGX,MAAOrP,GACP9G,EAAeJ,yCAAyCkH,EAAEC,WAE5D,OAAOX,EAWuB0C,0BAC9BgG,EACAoE,EACAE,EACAH,EACA5O,GAEA,MAAM0M,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAGDuR,QAAgBxE,EAAkBhQ,KAAM8P,EAAaoE,GAC3D,GAAI,IAAIrF,EAAQoF,GAAeQ,YAAYD,GACzC,UAAUzU,uCAAuCyU,EAAQzQ,cAG3D,MAAM+R,QAA0BjP,EAAc7G,KAAKsD,KAAM4Q,EAASD,GAElE,IAAI7M,EAAS,KAEb,IACE,MAAMgB,QAAe2J,EAAKvK,QACvB4P,oBACClD,EACAE,EACA0B,EACA9V,KAAKsD,KAAKqB,MAAMC,MAAMS,IAEvBoC,OAEHL,EAAS,CACP0P,kBAAmB5P,EAAclH,KAAKsD,KAAM8Q,EAAUhM,EAAOwM,gBAC7DmC,qCAAsC7P,EACpClH,KAAKsD,KACL4Q,EACA9L,EAAO4O,aAETC,qBAAsB/P,EAAclH,KAAKsD,KAAM4Q,EAAS9L,EAAO6O,gBAC/DC,iCAAkChQ,EAChClH,KAAKsD,KACL4Q,EACA9L,EAAO8O,4BAETC,iCAAkCjQ,EAChClH,KAAKsD,KACL4Q,EACA9L,EAAO+O,6BAGX,MAAOrP,GACP9G,EAAeJ,yCAAyCkH,EAAEC,WAE5D,OAAOX,EAQ4B0C,+BACnCgG,EACAoE,EACAD,GAEA,MAAMlC,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImE,EAAS,KAEb,IACE,MAAMgB,QAAe2J,EAAKvK,QACvB6P,oBACCnD,QACMrN,EAAc7G,KAAKsD,KAAM4Q,EAASD,IAEzCxM,OAEHL,QAAeF,EAAclH,KAAKsD,KAAMwM,EAAa1H,GACrD,MAAON,GACP9G,EAAeJ,2DACwCkH,EAAEC,WAG3D,OAAOX,EAQ4B0C,+BACnCgG,EACAoE,EACAa,GAEA,MAAMhD,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImE,EAAS,KACb,MAAMM,QAAwBb,EAAc7G,KAAKsD,KAAMwM,EAAaiF,GACpE,IACE,MAAM3M,QAAe2J,EAAKvK,QACvB8P,oBAAoBpD,EAASxM,GAE7BD,OAEHL,QAAeF,EAAclH,KAAKsD,KAAM4Q,EAAS9L,GACjD,MAAON,GACP9G,EAAeJ,2DACwCkH,EAAEC,WAG3D,OAAOX,EAQ4B0C,+BACnCgG,EACAsE,EACAmB,GAEA,MAAMxD,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImE,EAAS,KAEb,IACE,MAAMgB,QAAe2J,EAAKvK,QACvB+P,oBACCnD,QACMvN,EAAc7G,KAAKsD,KAAMwM,EAAayF,IAE7C9N,OACHL,QAAeF,EAAclH,KAAKsD,KAAM8Q,EAAUhM,GAClD,MAAON,GACP9G,EAAeJ,2DAA2DkH,KAE5E,OAAOV,EAQ4B0C,+BACnCgG,EACAsE,EACAQ,GAEA,MAAM7C,EAAOhP,EACX,SAASO,KAAKG,IAAI6D,SAAStH,KAAKuR,QAASzB,GACzC9P,KAAKiD,QAEP,IAAImE,EAAS,KAEb,IACE,MAAMgB,QAAe2J,EAAKvK,QACvBgQ,oBACCpD,QACMvN,EAAc7G,KAAKsD,KAAM8Q,EAAUQ,IAE1CnN,OAEHL,QAAeF,EAAclH,KAAKsD,KAAMwM,EAAa1H,GACrD,MAAON,GACP9G,EAAeJ,2DACwCkH,EAAEC,WAG3D,OAAOX,EAOFqQ,wBACL,MACMC,EADM1X,KAAKuR,QACKnF,KAAK,SAAUuL,GACnC,GAAe,aAAXA,EAAExV,MAAkC,UAAXwV,EAAEjV,KAAkB,OAAOiV,IAG1D,OADc3X,KAAKsD,KAAKG,IAAIgO,IAAImG,qBAAqBF,GAQhDG,wBACL,MACMH,EADM1X,KAAKuR,QACKnF,KAAK,SAAUuL,GACnC,GAAe,aAAXA,EAAExV,MAAkC,UAAXwV,EAAEjV,KAAkB,OAAOiV,IAG1D,OADc3X,KAAKsD,KAAKG,IAAIgO,IAAImG,qBAAqBF,GAQhDI,wBACL,MACMJ,EADM1X,KAAKuR,QACKnF,KAAK,SAAUuL,GACnC,GAAe,aAAXA,EAAExV,MAAkC,UAAXwV,EAAEjV,KAAkB,OAAOiV,IAG1D,OADc3X,KAAKsD,KAAKG,IAAIgO,IAAImG,qBAAqBF,UCtuD5CtM,GAcXvL,YACEyD,EACAsH,EAA2B,KAC3BmN,EAAoC,KACpC9U,QAjBK0J,iBAAmB,SACnBrJ,KAAa,UACbsH,6BACA3H,mBACA8U,yBACAC,yBAcLhY,KAAKsD,KAAOA,EACZtD,KAAK4K,iBAAmBA,EACxB5K,KAAK+X,aAAeA,GAAiBE,EAAoBxG,IACzDzR,KAAKiD,OAASA,GAAU6H,EAAqB,GACzCxH,IACFtD,KAAKgY,kBAAoBjV,EACvB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK+X,aAAc/X,KAAK4K,kBACnD5K,KAAKiD,SASQ6G,aAACoO,GAClB,IACE,MAAM9P,aAAoC4P,kBAAkBxQ,QACzDiJ,OAAOyH,GACPzQ,OAIH,OAHAW,EAAO+P,UAAYnY,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAO+P,WAClD/P,EAAOgQ,WAAapY,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAOgQ,YACnDhQ,EAAO+G,QAAUnP,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAO+G,SACzC/G,EACP,MAAON,GACPuQ,EAAO3X,8CAA8CwX,KAEvD,YAYuBpO,mBACvBwO,EACAjL,EACA8K,EACAC,EACAG,GAEA,MAAMnK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoB2J,kBAAkBxQ,QACnCgR,OACCF,EACAtY,KAAKsD,KAAKqB,MAAMC,MAAMuT,GACtBnY,KAAKsD,KAAKqB,MAAMC,MAAMwT,GACtB/K,EACAkL,GAEDhK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAYUvE,aACjBwO,EACAjL,EACA8K,EACAC,EACAG,GAEA,MAAMlK,aAAoBoK,aACxBH,EACAjL,EACA8K,EACAC,EACAG,GAiBF,kBAb8BP,kBAAkBxQ,QAC7CgR,OACCF,EACAtY,KAAKsD,KAAKqB,MAAMC,MAAMuT,GACtBnY,KAAKsD,KAAKqB,MAAMC,MAAMwT,GACtB/K,EACAkL,GAEDxJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAa3B6G,qBACzBwO,EACAH,EACAC,EACA/K,GAEA,IAAIgB,EACJ,MAAMD,EAAkBpO,KAAK2M,iBAC7B,IACE0B,aAAoB2J,kBAAkBxQ,QACnCkR,SACCJ,EACAtY,KAAKsD,KAAKqB,MAAMC,MAAMuT,GACtBnY,KAAKsD,KAAKqB,MAAMC,MAAMwT,IAEvB7J,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWYvE,eACnBwO,EACAH,EACAC,EACA/K,GAEA,IACE,MAAMgB,aAAoBsK,eAAeL,EAAWH,EAAWC,EAAY/K,GAY3E,kBAX8B2K,kBAAkBxQ,QAC7CkR,SACCJ,EACAtY,KAAKsD,KAAKqB,MAAMC,MAAMuT,GACtBnY,KAAKsD,KAAKqB,MAAMC,MAAMwT,IAEvBrJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GACPuQ,EAAOzX,8CAA8CkH,EAAEC,WAEzD,YAS2B+B,uBAACwO,EAAmBjL,GAC/C,IAAIgB,EACJ,MAAMD,EAAkBpO,KAAK2M,iBAC7B,IACE0B,aAAoB2J,kBAAkBxQ,QACnCoR,WAAWN,GACX/J,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAScvE,iBACrBwO,EACAjL,GAEA,IACE,MAAMgB,aAAoBwK,iBAAiBP,EAAWjL,GAMtD,kBAL8B2K,kBAAkBxQ,QAAQoR,WAAWN,GAAWvJ,KAAK,CACjFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGlD,MAAO6E,GACPuQ,EAAOzX,8CAA8CkH,EAAEC,WAEzD,YAUkC+B,8BAClCwO,EACAjL,EACAyL,GAEA,IAAIzK,EACJ,MAAMD,EAAkBpO,KAAK2M,iBAC7B,IACE0B,aAAoB2J,kBAAkBxQ,QACnCuR,kBAAkBT,EAAWQ,GAC7BvK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUqBvE,wBAC5BwO,EACAjL,EACAyL,GAEA,IACE,MAAMzK,aAAoB2K,wBACxBV,EACAjL,EACAyL,GASF,kBAP8Bd,kBAAkBxQ,QAC7CuR,kBAAkBT,EAAWQ,GAC7B/J,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GACPuQ,EAAOzX,8CAA8CkH,EAAEC,WAEzD,YAUyB+B,qBACzBwO,EACAjL,EACAjG,EAAiB,IACjB6R,GAEA,IAAI5K,EACJ,MAAMD,EAAkBpO,KAAK2M,iBAC7B,IACE0B,aAAoB2J,kBAAkBxQ,QACnC0R,SAASZ,EAAWtY,KAAKsD,KAAKqB,MAAMC,MAAMwC,GAAS6R,GACnD1K,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaYvE,eACnBwO,EACAjL,EACAjG,EAAiB,IACjB6R,GAEA,MAAM5K,aAAoB8K,eAAeb,EAAWjL,EAASjG,EAAQ6R,GACrE,IAQE,kBAP8BjB,kBAAkBxQ,QAC7C0R,SAASZ,EAAWtY,KAAKsD,KAAKqB,MAAMC,MAAMwC,GAAS6R,GACnDlK,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GACPuQ,EAAOzX,2CAA2CkH,EAAEC,WAEtD,YAU8B+B,0BAACwO,EAAmBjL,GAClD,IAAIgB,EACJ,MAAMD,EAAkBpO,KAAK2M,iBAC7B,IACE0B,aAAoB2J,kBAAkBxQ,QACnC4R,cAAcd,GACd/J,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASiBvE,oBACxBwO,EACAjL,GAEA,MAAMgB,aAAoBgL,oBAAoBf,EAAWjL,GACzD,IAQE,kBAP8B2K,kBAAkBxQ,QAC7C4R,cAAcd,GACdvJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GACPuQ,EAAOzX,2CAA2CkH,EAAEC,WAEtD,YAUwB+B,oBACxBwO,EACAgB,EACAjM,EACAjG,EAAiB,KAEjB,MAAMqJ,aAAoBA,OAAO6H,GACjC,SAAK7H,IAEiB,IAAlBA,EAAO8I,QAES,IAAI1K,QAAcyK,EAAUnK,QAAQmJ,EAAWjL,IACnDyB,qBAAqB2B,EAAO2H,aAExC,IAAIvJ,EAAQ2K,OAAOpS,IAASqN,YAAYhE,EAAO0H,aAE3B,IAAItJ,EAAQ4B,EAAOtB,SACvBL,qBAAqB1H,KAA+B,IAApBqJ,EAAOgJ,WCzYnDC,IAAAA,IAAZ,SAAYA,GACVA,2CACAA,+CAFF,CAAYA,KAAAA,cAMCC,GAkBX9Z,YACEyD,EACAqC,EACAiU,EAA4C,KAC5CC,EAAuB,KACvB5W,QAtBK0J,iBAAmB,SAEnBkN,aAAuB,UACvBlU,6BACAiU,iCACAE,8BACAxW,iBACAN,SAAqB,UAErBC,mBACA8W,aAcL/Z,KAAKsD,KAAOA,EACZtD,KAAKiD,OAASA,GAAU6H,EAAqB,GAC7C9K,KAAK4Z,qBACHA,GAAyBI,EAA4BvI,IACvDzR,KAAK6Z,aAAeA,EACpB7Z,KAAK2F,iBAAmBA,EACxB5E,QAAQP,IAAI,uBAAwBR,KAAKiD,QACzCjD,KAAKgD,SAAWD,EACd,SAASO,KAAKG,IAAI6D,SAAStH,KAAK4Z,qBAAsB5Z,KAAK2F,kBAC3D3F,KAAKiD,QAIU6G,oBAAC3C,EAAeC,GACjC,OAAOP,EAAc7G,KAAKsD,KAAM6D,EAAOC,GAGtB0C,oBAAC3C,EAAeC,GACjC,OAAOF,EAAclH,KAAKsD,KAAM6D,EAAOC,GASV0C,yBAACmQ,EAAmBX,GAIjD,kBAH8BtW,SAASwE,QACpC0S,mBAAmBD,EAAWX,GAC9B7R,OAcgBqC,eACnBkE,EACAmM,EACAC,EACAhV,EACAiV,EACAC,EACAnM,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtB+S,MACCJ,EACAC,EACAhV,EACAiV,EACAC,GAED/L,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaSvE,YAChBuD,EACAlI,EACAqV,EACApV,EACAiV,EAA+B,6CAC/BC,EAA2B,KAE3B,MAAMG,aAAsBC,YAAYvV,GAClCwV,EAA4B3a,KAAKsD,KAAKqB,MAAMC,MAAM0V,GAClDM,aAA+B/T,cACnC4T,EAASnB,UACTkB,GAEIK,aAA4BhU,cAChC4T,EAASR,UACT7U,GAGIiJ,aAAoByM,SACxBzN,EACAlI,EACAyV,EACAC,EACAR,EACAM,GAEF,IAcE,kBAb8B3X,SAASwE,QACpC+S,MACCpV,EACAyV,EACAC,EACAR,EACAM,GAED5L,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GAEP,OADA9G,EAAeJ,0CAA0CkH,EAAEC,iBAezC+B,gBACpBkE,EACAmM,EACAC,EACAhV,EACAiV,EACAC,EACAnM,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtBuT,OACCZ,EACAC,EACAhV,EACAiV,EACAC,GAED/L,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaUvE,aACjBuD,EACAlI,EACAqV,EACAQ,EACAX,EAA+B,6CAC/BC,EAA2B,KAE3B,MAAMG,aAAsBC,YAAYvV,GAClCwV,EAA4B3a,KAAKsD,KAAKqB,MAAMC,MAAM0V,GAClDM,aAA+B/T,cACnC4T,EAASnB,UACTkB,GAEIS,aAA4BpU,cAChC4T,EAASR,UACTe,GAEI3M,aAAoByM,SACxBzN,EACAlI,EACAyV,EACAK,EACAZ,EACAM,GAEF,IAcE,kBAb8B3X,SAASwE,QACpCuT,OACC5V,EACAyV,EACAK,EACAZ,EACAM,GAED5L,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GAEP,OADA9G,EAAeJ,2CAA2CkH,EAAEC,iBAW/B+B,6BAE/B,kBADgC9G,SAASwE,QAAQ0T,uBAAuBzT,OAYnDqC,iBACrBkE,EACA7I,EACAgW,EACAhN,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtB4T,QAAQjW,aAAuB7B,KAAKqB,MAAMC,MAAMuW,IAChD5M,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUWvE,cAClBuD,EACAlI,EACAgW,GAEA,MAAM9M,aAAoBgN,WAAWhO,EAASlI,EAAYgW,GAQ1D,kBAP8BnY,SAASwE,QACpC4T,QAAQjW,EAAYnF,KAAKsD,KAAKqB,MAAMC,MAAMuW,IAC1CpM,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAarB6G,2BAC/BkE,EACA7I,EACA2T,EACA3K,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtB4T,QAAQjW,EAAY2T,GACpBvK,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUqBvE,wBAC5BuD,EACAlI,EACA2T,GAEA,MAAMzK,aAAoBiN,qBAAqBjO,EAASlI,EAAY2T,GAQpE,kBAP8B9V,SAASwE,QACpCuR,kBAAkB5T,EAAY2T,GAC9B/J,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAY9B6G,kBACtBkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtB+T,oBAAoBpW,GACpBoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASYvE,eACnBuD,EACAlI,GAEA,MAAMsV,aAAsBC,YAAYvV,GACxC,IAAKsV,EAAU,YACf,IAAwB,IAApBA,EAASlB,OAAiB,YAE9B,MAAMlL,aAAoBmN,YAAYnO,EAASlI,GAM/C,kBAL8BnC,SAASwE,QAAQ+T,oBAAoBpW,GAAY4J,KAAK,CAClFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAY1B6G,oBACxBkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtB+T,oBAAoBpW,GACpBoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAScvE,iBACrBuD,EACAlI,GAEA,MAAMsV,aAAsBC,YAAYvV,GACxC,IAAKsV,EAAU,YACf,IAAwB,IAApBA,EAASlB,OAAkB,YAE/B,MAAMlL,aAAoBoN,cAAcpO,EAASlI,GAQjD,kBAN8BnC,SAASwE,QAAQ+T,oBAAoBpW,GAAY4J,KAAK,CAClFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAWhC6G,cAAC3E,GACnB,MAAMuW,aAAqB1Y,SAASwE,QAAQmU,QAAQxW,GAAYsC,OAEhE,kBADwBnE,KAAKqB,MAAM+M,QAAQgK,GASrB5R,kBAAC3E,GACvB,MAAMyW,aAAsB5Y,SAASwE,QAAQqU,YAAY1W,GAAYsC,OACrE,kBAAkBP,0BAEHwT,YAAYvV,IACvBmU,UACFsC,GASoB9R,kBAAC3E,GACvB,MAAM2W,aAAsB9Y,SAASwE,QAAQuU,YAAY5W,GAAYsC,OACrE,kBAAkBP,0BAEHwT,YAAYvV,IACvB8U,UACF6B,GAS0BhS,wBAAC3E,GAC7B,kBAAkBnC,SAASwE,QAAQwU,kBAAkB7W,GAAYsC,OAUlCqC,2BAC/B3E,EACAqV,EACAF,EAA2B,KAE3B,MAAM2B,aAA+BvB,YAAYvV,GACjDpE,QAAQP,IACN,wCACAR,KAAKgD,SAASE,wBACdlD,KAAKgD,SAASG,8BACdnD,KAAKgD,SAASI,2BAEhB,MAAMgF,aAAoBpF,SAASwE,QAChC0U,qBACC/W,aACW0B,cAAcoV,EAAkB3C,UAAWkB,GACtDxa,KAAKsD,KAAKqB,MAAMC,MAAM0V,IAEvB7S,OAoBH,MAlBqB,CACnB0U,2BAA4BjV,cAC1B+U,EAAkBhC,UAClB7R,EAAO+T,iBAETC,2BAA4BlV,cAC1B+U,EAAkBhC,UAClB7R,EAAOgU,iBAETnF,0BAA2B/P,cACzB+U,EAAkBhC,UAClB7R,EAAO6O,gBAEToF,kCAAmCnV,cACjC+U,EAAkBhC,UAClB7R,EAAOiU,yBAacvS,qBACzB3E,EACAqV,EACAF,EAA2B,KAE3B,MAAMG,aAAsBC,YAAYvV,GAClCiD,aAAoBpF,SAASwE,QAChC8U,qBACCnX,aACW0B,cAAc4T,EAASnB,UAAWkB,GAC7Cxa,KAAKsD,KAAKqB,MAAMC,MAAM0V,IAEvB7S,OAEH,kBAAkBP,0BAEHwT,YAAYvV,IACvB8U,UACF7R,EAAO,IASa0B,kBAAC3E,GACvB,MAAMiD,aAAwCpF,SAASwE,QACpDkT,YAAYvV,GACZsC,OASH,OARAW,EAAOmU,WAAanU,EAAOmU,WAAWxY,WACtCqE,EAAOoU,WAAapU,EAAOoU,WAAWzY,WACtCqE,EAAOqU,qBAAuBvV,cAAckB,EAAOkR,UAAWlR,EAAOqU,WACrErU,EAAOsU,qBAAuBxV,cAAckB,EAAO6R,UAAW7R,EAAOsU,WACrEtU,EAAOwT,oBAAsB1U,cAAckB,EAAOkR,UAAWlR,EAAOwT,UACpExT,EAAO0T,oBAAsB5U,cAAckB,EAAO6R,UAAW7R,EAAO0T,UACpE1T,EAAOnC,UAAYjG,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAOnC,WAClDmC,EAAOjD,WAAaA,EACbiD,EAQe0B,kBAAC3E,GACvB,MAAMiD,aAA8BpF,SAASwE,QAAQmV,YAAYxX,GAAYsC,OAkB7E,OAjBAW,EAAOwU,OAAS5c,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAOwU,OAAO7Y,YACtDqE,EAAOlC,UAAYlG,KAAKsD,KAAKqB,MAAM+M,QAAQtJ,EAAOlC,UAAUnC,YAE5DqE,EAAOyU,8BAAgC3V,0BAExBwT,YAAYvV,IACvB8U,UACF7R,EAAOyU,oBAETzU,EAAO0U,6BAA+B5V,0BAEvBwT,YAAYvV,IACvB8U,UACF7R,EAAO0U,mBAGT1U,EAAOjD,WAAaA,EACbiD,EAQgB0B,qBACvB,kBAAkB9G,SAASwE,QAAQuV,eAAetV,OAQ/BqC,eAAC3E,GAEpB,kBAD0BnC,SAASwE,QAAQwV,SAAS7X,GAAYsC,OAWtCqC,sBAC1BkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtByV,gBAAgB9X,GAAY,GAC5BoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASgBvE,mBACvBuD,EACAlI,GAEA,MAAMsV,aAAsBC,YAAYvV,GACxC,IAAKsV,EAAU,YACf,IAA0B,IAAtBA,EAAShV,SAAmB,YAEhC,MAAM4I,aAAoB6O,gBAAgB7P,EAASlI,GAQnD,kBAP8BnC,SAASwE,QACpCyV,gBAAgB9X,GAAY,GAC5B4J,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYxB6G,wBAC5BkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtByV,gBAAgB9X,GAChBoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASkBvE,qBACzBuD,EACAlI,GAEA,MAAMsV,aAAsBC,YAAYvV,GACxC,IAAKsV,EAAU,YACf,IAA0B,IAAtBA,EAAShV,SAAoB,YAEjC,MAAM4I,aAAoBoN,cAAcpO,EAASlI,GAUjD,kBAR8BnC,SAASwE,QACpCyV,gBAAgB9X,GAAY,GAC5B4J,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAc7B6G,mBACvBkE,EACA7I,EACAiC,EACA+G,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,MAAM8O,aAA2Cna,SAASwE,QACvDkT,YAAYvV,GACZsC,OACG2V,aAAuBvW,cAAcsW,EAAUlD,UAAW7S,GAChE,IACEiH,QAAepI,EAAUuB,QACtB6V,UAAUlY,EAAYiY,GACtB7O,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUavE,gBACpBuD,EACAlI,EACAiC,GAGA,eAD4BsT,YAAYvV,GACzB,YAEf,MAAMkJ,aAAoBiP,aAAajQ,EAASlI,EAAYiC,GACtD+V,aAA2Cna,SAASwE,QACvDkT,YAAYvV,GACZsC,OACG2V,aAAuBvW,cAAcsW,EAAUlD,UAAW7S,GAMhE,kBAL8BpE,SAASwE,QAAQ6V,UAAUlY,EAAYiY,GAAWrO,KAAK,CACnFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAa3B6G,mBACvBkE,EACA7I,EACAiC,EACA+G,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,MAAM8O,aAA2Cna,SAASwE,QACvDkT,YAAYvV,GACZsC,OACG2V,aAAuBvW,cAAcsW,EAAU7D,UAAWlS,GAChE,IACEiH,QAAepI,EAAUuB,QACtB+V,UAAUpY,EAAYiY,GACtB7O,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUavE,gBACpBuD,EACAlI,EACAiC,GAGA,eAD4BsT,YAAYvV,GACzB,YAEf,MAAMkJ,aAAoBmP,aAAanQ,EAASlI,EAAYiC,GACtD+V,aAA2Cna,SAASwE,QACvDkT,YAAYvV,GACZsC,OACG2V,aAAuBvW,cAAcsW,EAAU7D,UAAWlS,GAMhE,kBAL8BpE,SAASwE,QAAQ+V,UAAUpY,EAAYiY,GAAWrO,KAAK,CACnFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYpB6G,0BAC9BkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtBgM,iBAAiBrO,GACjBoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASoBvE,uBAC3BuD,EACAlI,GAGA,eAD4BuV,YAAYvV,GACzB,YAEf,MAAMkJ,aAAoBqF,oBAAoBrG,EAASlI,GAMvD,kBAL8BnC,SAASwE,QAAQgM,iBAAiBrO,GAAY4J,KAAK,CAC/EP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYrB6G,yBAC7BkE,EACA7I,EACAgJ,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtBgM,iBAAiBrO,GACjBoJ,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASmBvE,sBAC1BuD,EACAlI,GAGA,eAD4BuV,YAAYvV,GACzB,YAEf,MAAMkJ,aAAoBoP,mBAAmBpQ,EAASlI,GAMtD,kBAL8BnC,SAASwE,QAAQkW,gBAAgBvY,GAAY4J,KAAK,CAC9EP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAS/B6G,wBACnB,IAAI1B,EAAS,KACb,IACEA,aAAoBpF,SAASwE,QAAQmW,eAAelW,OACpD,MAAOK,GACP9G,EAAeJ,qDAAqDkH,EAAEC,WAExE,OAAOK,EAOM0B,kBACb,IAAI1B,EAAS,KACb,IACEA,aAAoBpF,SAASwE,QAAQoW,SAASnW,OAC9C,MAAOK,GACP9G,EAAeJ,8CAA8CkH,EAAEC,WAEjE,OAAOK,EAQa0B,uBAAC3E,GACrB,IAAIiD,EAAS,KACb,IACEA,mBAA2BsS,YAAYvV,IAAa0Y,cACpD,MAAO/V,GACP9G,EAAeJ,qDAAqDkH,EAAEC,WAExE,OAAOK,EAWsB0B,yBAC7BkE,EACA7I,EACA2Y,EACA3P,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtBuW,gBAAgB5Y,EAAY2Y,GAC5BvP,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUmBvE,sBAC1BuD,EACAlI,EACA2Y,GAEA,MAAMzP,aAAoBgN,WACxBhO,EACAlI,EACAnF,KAAKsD,KAAKqB,MAAMC,MAAMkZ,IASxB,kBAP8B9a,SAASwE,QACpCuW,gBAAgB5Y,EAAYnF,KAAKsD,KAAKqB,MAAMC,MAAMkZ,IAClD/O,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAad6G,kCACtCkE,EACA7I,EACA6Y,EACA7P,GAEA,MAAMlI,EAAYkI,GAAoBnO,KAAK8Z,kBACrC1L,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAepI,EAAUuB,QACtByW,yBAAyB9Y,EAAY6Y,GACrCzP,YAAY,CAAEC,KAAMR,GAAW,CAACS,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAU4BvE,+BACnCuD,EACAlI,EACA6Y,GAEA,MAAM3P,aAAoB6P,4BACxB7Q,EACAlI,EACA6Y,GASF,kBAP8Bhb,SAASwE,QACpCyW,yBAAyB9Y,EAAY6Y,GACrCjP,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,iBCrnC3Ckb,GASXte,YAAYyD,EAAY8a,EAA8Bnb,QAR/C0J,iBAAmB,SACnB0R,8BACAC,0BACAF,mBACA9a,iBACAuH,uBACA5H,cAGLjD,KAAKoe,OAASA,GAAWG,EAAc9M,IACvCzR,KAAKsD,KAAOA,EACZtD,KAAKiD,OAASA,GAAU6H,EAAqB,GAmBjBhB,wBAC5B0U,EACAnR,EACAhJ,EACAC,EACAC,EACAC,EACAM,EACAD,EACA1C,EACAC,EACA8B,EACAiK,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBkX,YACCxa,EACA,CAAC/B,EAAMC,GACP,CAACiC,EAAQC,EAAkBC,EAAcC,GACzC,CAACxE,KAAKsD,KAAKqB,MAAMC,MAAMC,GAAM7E,KAAKsD,KAAKqB,MAAMC,MAAME,IACnD,IAEDyJ,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAkBevE,kBACtB0U,EACAnR,EACAhJ,EACAC,EACAC,EACAC,EACAM,EACAD,EACA1C,EACAC,EACA8B,GAEA,IAAwE,gBAAxDya,kBAAkBH,EAAYnR,IAAUuR,YACtD,UAAU7e,qCAEPmE,IAAeA,EAAgB,GAG/B/B,GAASC,KACRD,KAAAA,EAAMC,OAAAA,GAAWnB,KAIvB,MAAMwd,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGDoL,aAAoBwQ,kBACxBL,EACAnR,EACAhJ,EACAC,EACAC,EACAC,EACAM,EACAD,EACA1C,EACAC,EACA8B,EACAua,GAIIvP,QAAmBuP,EAAYjX,QAClCkX,YACCxa,EACA,CAAC/B,EAAMC,GACP,CAACiC,EAAQC,EAAkBC,EAAcC,GACzC,CAACxE,KAAKsD,KAAKqB,MAAMC,MAAMC,GAAM7E,KAAKsD,KAAKqB,MAAMC,MAAME,IACnD,IAEDiK,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,IAAIgL,EAAe,KACnB,IACEA,EAAeiB,EAAW4P,OAAOC,aAAaC,aAAa,GAC3D,MAAOlX,GACP9G,EAAeJ,6CAA6CkH,EAAEC,WAEhE,OAAOkG,EAWoBnE,uBAC3B0U,EACAnR,EACA4R,EACA9Q,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxB0X,WAAWD,GACX1Q,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUcvE,iBAAC0U,EAAoBnR,EAAiB4R,GAC3D,MAAMR,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,cAAgBkc,YAAYX,KAAiBnR,EAC3C,UAAUtN,iCAGZ,MAAMsO,aAAoB+Q,iBAAiBZ,EAAYnR,EAAS4R,EAASR,GASzE,aANyBA,EAAYjX,QAAQ0X,WAAWD,GAASlQ,KAAK,CACpEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcpB6G,0BAC9B0U,EACAnR,EACA4R,EACA9Q,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxB6X,cAAcJ,GACd1Q,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUiBvE,oBAAC0U,EAAoBnR,EAAiB4R,GAC9D,MAAMR,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,cAAgBkc,YAAYX,KAAiBnR,EAC3C,UAAUtN,iCAGZ,MAAMsO,aAAoBiR,oBACxBd,EACAnR,EACA4R,EACAR,GAUF,aANyBA,EAAYjX,QAAQ6X,cAAcJ,GAASlQ,KAAK,CACvEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcjB6G,6BACjC0U,EACAnR,EACAkS,EACApR,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBgY,qBAAqBD,GACrBhR,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAUoBvE,uBAC3B0U,EACAnR,EACAkS,GAEA,MAAMd,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IAAoE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,QACtD,UAAUlf,+BAIZ,MAAMsO,aAAoBoR,uBACxBjB,EACAnR,EACAkS,EACAd,GAYF,aARyBA,EAAYjX,QAClCgY,qBAAqBD,GACrBxQ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAchB6G,gCACpC0U,EACAnR,EACAkS,EACApR,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBkY,0BAA0BH,GAC1BhR,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAUuBvE,0BAC9B0U,EACAnR,EACAkS,GAEA,MAAMd,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IACkE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,SACnD5R,IAAYkS,IACyD,gBAAxDZ,kBAAkBH,EAAYnR,IAAUuR,YAEtD,UAAU7e,iDAEZ,MAAMsO,aAAoBsR,0BACxBnB,EACAnR,EACAkS,EACAd,GAYF,aARyBA,EAAYjX,QAClCoY,0BAA0BL,GAC1BxQ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcjB6G,+BACnC0U,EACAnR,EACAwS,EACA1R,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBsY,kBAAkBD,GAClBtR,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUsBvE,yBAC7B0U,EACAnR,EACAwS,GAEA,MAAMpB,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IAAoE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,QACtD,UAAUlf,+BAGZ,MAAMsO,aAAoB0R,yBACxBvB,EACAnR,EACAwS,EACApB,GAUF,aANyBA,EAAYjX,QAAQsY,kBAAkBD,GAAiB9Q,KAAK,CACnFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcb6G,iCACrC0U,EACAnR,EACAwS,EACA1R,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBwY,uBAAuBH,GACvBtR,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAUyBvE,4BAChC0U,EACAnR,EACAwS,GAEA,MAAMpB,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IACkE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,SACnD5R,IAAYwS,IAC4D,gBAA3DlB,kBAAkBH,EAAYnR,IAAU4S,eAEtD,UAAUlgB,oDAGZ,MAAMsO,aAAoB6R,2BACxB1B,EACAnR,EACAwS,EACApB,GAYF,aARyBA,EAAYjX,QAClCwY,uBAAuBH,GACvB9Q,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcpB6G,4BAChC0U,EACAnR,EACA8S,EACAhS,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxB4Y,kBAAkBD,GAClB5R,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUmBvE,sBAC1B0U,EACAnR,EACA8S,GAEA,MAAM1B,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IAAoE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,QACtD,UAAUlf,+BAGZ,MAAMsO,aAAoBgS,sBACxB7B,EACAnR,EACA8S,EACA1B,GAUF,aANyBA,EAAYjX,QAAQ4Y,kBAAkBD,GAAcpR,KAAK,CAChFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcf6G,+BACnC0U,EACAnR,EACA8S,EACAhS,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxB8Y,uBAAuBH,GACvB5R,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUsBvE,yBAC7B0U,EACAnR,EACA8S,GAEA,MAAM1B,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,IACkE,gBAApD0b,kBAAkBH,EAAYnR,IAAU4R,SACnD5R,IAAY8S,IACmD,gBAAlDxB,kBAAkBH,EAAYnR,IAAUkT,MAEtD,UAAUxgB,gDAGZ,MAAMsO,aAAoBmS,yBACxBhC,EACAnR,EACA8S,EACA1B,GAYF,aARyBA,EAAYjX,QAClC8Y,uBAAuBH,GACvBpR,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAanB6G,6BACjC0U,EACAnR,EACAc,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBiZ,mBACAlS,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAaoBvE,uBAC3B0U,EACAnR,GAEA,MAAMoR,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,cAAgBkc,YAAYX,KAAiBnR,EAC3C,UAAUtN,iCAGZ,MAAMsO,aAAoBqS,uBAAuBlC,EAAYnR,EAASoR,GAStE,aANyBA,EAAYjX,QAAQiZ,mBAAmB1R,KAAK,CACnEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAetB6G,wBAC5B0U,EACAmC,EACAC,EACAC,EACA1S,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBsZ,aAAaH,EAAUC,EAAaC,GACpCtS,YAAY,CAAEC,KAAMmS,GAAY,CAAClS,EAAKJ,IACrCI,EAAML,EAAkBC,GAE5B,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAYevE,kBACtB0U,EACAmC,EACAC,EACAC,GAEA,MAAMpC,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,cAAgBkc,YAAYX,KAAiBmC,EAC3C,UAAU5gB,iCAGZ,MAAMghB,EAAkBF,GAAW,EAE7BxS,aAAoB2S,kBACxBxC,EACAmC,EACAC,EACAG,EACAtC,GAYF,aARyBA,EAAYjX,QAClCsZ,aAAaH,EAAUC,EAAaG,GACpChS,KAAK,CACJP,KAAMmS,EACN3R,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAepB6G,4BAChC0U,EACAmC,EACAC,EACAC,EACA1S,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxByZ,iBAAiBN,EAAUC,EAAaC,GACxCtS,YAAY,CAAEC,KAAMmS,GAAY,CAAClS,EAAKJ,IACrCI,EAAML,EAAkBC,GAE5B,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAYmBvE,sBAC1B0U,EACAmC,EACAC,EACAC,GAEA,MAAMpC,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,cAAgBkc,YAAYX,KAAiBmC,EAC3C,UAAU5gB,iCAGZ,MAAMghB,EAAkBF,GAAW,EAE7BxS,aAAoB6S,sBACxB1C,EACAmC,EACAC,EACAG,EACAtC,GAYF,aARyBA,EAAYjX,QAClCyZ,iBAAiBN,EAAUC,EAAaG,GACxChS,KAAK,CACJP,KAAMmS,EACN3R,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAiBxB6G,wBAC5B0U,EACAqB,EACAsB,EACAC,EACAC,EACAC,EACA7X,EACA8X,EACAC,EACArT,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEJue,IAAgBA,EAAiB,IACtC,MAAMpT,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBia,YACCN,EACAC,EACAC,EACAC,EACA7X,EACA8X,EACAC,GAEDjT,YAAY,CAAEC,KAAMqR,GAAmB,CAACpR,EAAKJ,IAC5CI,EAAML,EAAkBC,GAE5B,MAAOvG,GACP9G,EAAeJ,MAAM,4BAA6BkH,EAAEC,SACpDsG,EAASD,EAGX,OAAOC,EAUevE,kBACtB0U,EACAnR,EACA8T,EACAC,EACAC,EACAC,EACA7X,EACA8X,EACAC,GAEA,MAAM/C,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,GADKue,IAAgBA,EAAiB,iBACrB7C,kBAAkBH,EAAYnR,IAAU4S,eACvD,UAAUlgB,wCAEZ,MAAMsO,aAAoBqT,kBACxBlD,EACAnR,EACA8T,EACAC,EACAC,EACAC,EACA7X,EACA8X,EACAC,EACA/C,GAkBF,aAhByBA,EAAYjX,QAClCia,YACCN,EACAC,EACAC,EACAC,EACA7X,EACA8X,EACAC,GAEDzS,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcb6G,mCACvC0U,EACAqB,EACA8B,EACAxT,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,MAAMuT,OACDD,GACHH,eAAgBG,EAAoBH,gBAAkB,KAExD,IACEnT,QAAeoQ,EAAYjX,QACxBqa,uBAAuBD,GACvBrT,YAAY,CAAEC,KAAMqR,GAAmB,CAACpR,EAAKJ,IAC5CI,EAAML,EAAkBC,GAE5B,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAU0BvE,6BACjC0U,EACAqB,EACA8B,GAEA,MAAMlD,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEP,gBAAiB0b,kBAAkBH,EAAYqB,IAAkBI,eAC/D,UAAUlgB,wCAEZ,MAAMsO,aAAoByT,6BACxBtD,EACAqB,EACA8B,EACAlD,GAEImD,OACDD,GACHH,eAAgBG,EAAoBH,gBAAkB,KAUxD,aARyB/C,EAAYjX,QAClCqa,uBAAuBD,GACvB7S,KAAK,CACJP,KAAMqR,EACN7Q,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcnB6G,6BACjC0U,EACAqB,EACAsB,EACAhT,GAEA,MAAMsQ,EACJtQ,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBua,iBAAiBZ,GACjB5S,YAAY,CAAEC,KAAMqR,GAAmB,CAACpR,EAAKJ,IAC5CI,EAAML,EAAkBC,GAE5B,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAUoBvE,uBAC3B0U,EACAnR,EACA8T,GAEA,MAAM1C,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,gBAAiB0b,kBAAkBH,EAAYnR,IAAU4S,eACvD,UAAUlgB,wCAGZ,MAAMsO,aAAoB2T,uBAAuBxD,EAAYnR,EAAS8T,GAStE,aANyB1C,EAAYjX,QAAQua,iBAAiBZ,GAAepS,KAAK,CAChFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYzB6G,qBACzB0U,EACAnR,EACA5D,GAEA,MAAMgV,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGDmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAeoQ,EAAYjX,QACxBya,YAAY,IAAKxY,GACjB8E,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EASevE,kBACtB0U,EACAnR,EACA5D,GAEA,MAAMgV,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGDoL,aAAoB6T,eAAe1D,EAAYnR,EAAS5D,GAM9D,aALyBgV,EAAYjX,QAAQya,YAAY,IAAKxY,GAAMsF,KAAK,CACvEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAS5B6G,kBAAC0U,GACvB,MAAMC,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,aADyBwb,EAAYjX,QAAQ2a,QAAQ,GAAG1a,OAS5BqC,wBAAC0U,EAAoBnR,GACjD,MAAMoR,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,aADoBwb,EAAYjX,QAAQ4a,eAAe/U,GAAS5F,OAQ1CqC,kBAAC0U,GACvB,MAAMC,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAEP,aAAawb,EAAYjX,QAAQ6a,cAAc5a,OAQrBqC,sBAAC0U,EAAoBnR,GAC/C,MAAMoR,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,aAD8Bwb,EAAYjX,QAAQ8a,gBAAgBjV,GAAS5F,OASzDqC,cAAC0U,EAAoB+D,GACvC,MAAM9D,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,aADmBwb,EAAYjX,QAAQmC,QAAQ4Y,GAAK9a,OAS9BqC,kBAAC0U,EAAoBgE,GAC3C,MAAM/D,EAAc1b,EAClB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKoe,OAAQI,GACxCxe,KAAKiD,QAGP,aADmBwb,EAAYjX,QAAQib,SAASD,GAAI/a,cCnzC3Cib,GAeX7iB,YACEyD,EACAqf,EACAC,EACA3f,QAlBK0J,iBAAmB,SACnBkW,2BACAC,uBACAH,0BACAC,oCACAtf,iBACAL,mBACA8f,WAaL/iB,KAAKsD,KAAOA,EACZtD,KAAK2iB,cAAgBA,GAAkBK,EAAqBvR,IAC5DzR,KAAK4iB,wBACHA,GAA4BK,EAA+BxR,IAC7DzR,KAAKiD,OAASA,GAAU6H,EAAqB,GAC7C9K,KAAK+iB,IAAM,IAAI5E,GAAIne,KAAKsD,MAYAwG,oBACxBwO,EACApK,EACA9G,EACAiG,EACAc,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAIHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvB8G,QAAQJ,EAASlO,KAAKsD,KAAKqB,MAAMC,MAAMwC,IACvCmH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWWvE,cAClBwO,EACApK,EACA9G,EACAiG,GAEA,MAAM6V,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGDoL,aAAoB8U,cACxB7K,EACApK,EACA9G,EACAiG,EACA6V,GAWF,aAPyBA,EAAW1b,QACjC8G,QAAQJ,EAASlO,KAAKsD,KAAKqB,MAAMC,MAAMwC,IACvC2H,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAc/B6G,iBACrBwO,EACAjL,EACAjG,EACAgc,EACAjV,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvB6b,KAAKD,GAAa/V,EAASrN,KAAKsD,KAAKqB,MAAMC,MAAMwC,IACjDmH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAYyBvE,4BAChCwO,EACAjL,EACAiW,EACAnV,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAExB2W,EAAgB9d,kBACnB8d,EAAgB9d,gBAAkB,8CACpC,MAAMC,EAAW6d,EAAgB7d,SAAW,EAAI,EAEhD,IAAI4I,EACJ,IACEA,QAAe6U,EAAW1b,QACvB+b,gBACCD,EAAgB3d,iBAChB,CACE2d,EAAgB1d,iBAChByH,EACAiW,EAAgBxd,mBAChBwd,EAAgB9d,iBAElB,CACE8d,EAAgBvd,kBAChBud,EAAgBtd,kBAChBsd,EAAgBrd,UAChBqd,EAAgBpd,UAChBT,IAGH8I,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAWmBvE,sBAC1BwO,EACAjL,EACAiW,GAEA,MAAMJ,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAEP,eAAiBqf,gBAAgBhK,EAAWjL,GAC1C,UAAUtN,oCAEPujB,EAAgB9d,kBACnB8d,EAAgB9d,gBAAkB,8CAEpC,MAAMC,EAAW6d,EAAgB7d,SAAW,EAAI,EAI1C4I,aAAoBmV,sBACxBlL,EACAjL,EACAiW,EACAJ,GA0BF,aAtByBA,EAAW1b,QACjC+b,gBACCD,EAAgB3d,iBAChB,CACE2d,EAAgB1d,iBAChB0d,EAAgBzd,MAChByd,EAAgBxd,mBAChBwd,EAAgB9d,iBAElB,CACE8d,EAAgBvd,kBAChBud,EAAgBtd,kBAChBsd,EAAgBrd,UAChBqd,EAAgBpd,UAChBT,IAGHsJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcpB6G,4BAChCwO,EACAjL,EACAzC,EACA6Y,EACAtV,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGJwgB,EAAgBlL,iBACnBkL,EAAgBlL,eAAiB,8CAE9BkL,EAAgBhe,WAAUge,EAAgBhe,UAAW,GAE1D,MAAM2I,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBkc,gBACC9Y,EACA6Y,EAAgBtL,UAChBsL,EAAgBrL,WAChBqL,EAAgBhe,SAChBge,EAAgBlL,gBAEjBhK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAWmBvE,sBAC1BwO,EACAjL,EACAzC,EACA6Y,GAEA,eAAiBnB,gBAAgBhK,EAAWjL,GAC1C,UAAUtN,oCAGZ,MAAMmjB,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGFwgB,EAAgBlL,iBACnBkL,EAAgBlL,eAAiB,8CAE9BkL,EAAgBhe,WAAUge,EAAgBhe,UAAW,GAI1D,MAAM4I,aAAoBsV,sBACxBrL,EACAjL,EACAzC,EACA6Y,EACAP,GAiBF,aAbyBA,EAAW1b,QACjCkc,gBACC9Y,EACA6Y,EAAgBtL,UAChBsL,EAAgBrL,WAChBqL,EAAgBhe,SAChBge,EAAgBlL,gBAEjBxJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAarC6G,WACfwO,EACAjL,EACAjG,EACAgc,GAEA,MAAMF,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,IAAiE,gBAAjD2gB,iBAAiBtL,EAAWjL,IAAUhJ,OACpD,UAAUtE,8BAGZ,MAAM8jB,aAAyBC,OAAOxL,GACtC,GAAI,IAAIzJ,EAAQgV,GAAaE,IAAI3c,GAAS,CACxC,MAAMiH,aAAoB2V,WACxB1L,EACAjL,EACAjG,EACAgc,EACAF,GAWF,aAPyBA,EAAW1b,QACjC6b,KAAKD,GAAa/V,EAASrN,KAAKsD,KAAKqB,MAAMC,MAAMwC,IACjD2H,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAIpD,UAAUlD,2CAYc+J,sBAC1BwO,EACAjL,EACAhJ,EACA8J,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAIHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvByc,UAAU5f,GACVkK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWavE,gBACpBwO,EACAjL,EACAhJ,GAEA,MAAM6e,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,IAAyD,eAAzCqf,gBAAgBhK,EAAWjL,GACzC,UAAUtN,qCAGZ,MAAMsO,aAAoB6V,gBAAgB5L,EAAWjL,EAAShJ,EAAQ6e,GAStE,aANyBA,EAAW1b,QAAQyc,UAAU5f,GAAQ0K,KAAK,CACjEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcrB6G,yBAC7BwO,EACAjL,EACAhJ,EACA8J,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAMHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvB2c,aAAa9f,GACbkK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAYgBvE,mBACvBwO,EACAjL,EACAhJ,GAEA,MAAM6e,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,IAAyD,eAAzCqf,gBAAgBhK,EAAWjL,GACzC,UAAUtN,qCAGZ,MAAMsO,aAAoB+V,mBAAmB9L,EAAWjL,EAAShJ,EAAQ6e,GASzE,aANyBA,EAAW1b,QAAQ2c,aAAa9f,GAAQ0K,KAAK,CACpEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAchB6G,8BAClCwO,EACAjL,EACAgX,EACAlW,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAIHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvB8c,kBAAkBD,GAClB9V,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAWqBvE,wBAC5BwO,EACAjL,EACAgX,GAEA,MAAMnB,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,IAAyD,eAAzCqf,gBAAgBhK,EAAWjL,GACzC,UAAUtN,qCAGZ,MAAMsO,aAAoBkW,wBACxBjM,EACAjL,EACAgX,EACAnB,GAUF,aANyBA,EAAW1b,QAAQ8c,kBAAkBD,GAAgBtV,KAAK,CACjFP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcb6G,iCACrCwO,EACAjL,EACAgX,EACAlW,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBgd,qBAAqBH,GACrB9V,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWwBvE,2BAC/BwO,EACAjL,EACAgX,GAEA,MAAMnB,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,IAAyD,eAAzCqf,gBAAgBhK,EAAWjL,GACzC,UAAUtN,qCAGZ,MAAMsO,aAAoBoW,2BACxBnM,EACAjL,EACAgX,EACAnB,GAYF,aARyBA,EAAW1b,QACjCgd,qBAAqBH,GACrBtV,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAchB6G,gCACpCwO,EACAjL,EACA/I,EACA6J,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBkd,oBAAoBpgB,GACpBiK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAYuBvE,0BAC9BwO,EACAjL,EACA/I,GAEA,MAAM4e,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAED0hB,GACiE,gBAAzDf,iBAAiBtL,EAAWjL,IAAUgX,eAC9C7F,GAAcmG,cAAgCC,cAActM,GAC5DuM,EAAarG,cAA0BuE,IAAI5D,YAAYX,KAAiBnR,EACxEyX,EACJtG,IAAeqG,cAA0B9B,IAAIpE,kBAAkBH,EAAYnR,GAE7E,IAAKsX,IAAqBE,WADFC,SAAAA,EAAgBlG,aAEtC,UAAU7e,4DAGZ,MAAMsO,aAAoB0W,0BACxBzM,EACAjL,EACA/I,EACA4e,GAYF,aARyBA,EAAW1b,QACjCkd,oBAAoBpgB,GACpByK,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAUtB6G,0BAACwO,GAC/B,MAAM4K,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,aAD+BigB,EAAW1b,QAAQwd,sBAAsBvd,OAYrDqC,eACnBwO,EACA8K,EACAhc,EACAiG,GAEA,MAAM4X,EAAYjlB,KAAKsD,KAAKqB,MAAMC,MAAMwC,GACxC,YAAY8d,YAAY5M,EAAW8K,EAAW6B,EAAW5X,GAYhCvD,qBACzBwO,EACA8K,EACAhc,EACAiG,EACAc,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvB2d,SAAS/B,EAAWhc,GACpBmH,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWevE,kBACtBwO,EACA8K,EACAhc,EACAiG,GAEA,MAAM6V,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAEP,IACE,MAAMoL,aAAoB+W,eACxB9M,EACA8K,EACAhc,EACAiG,EACA6V,GAQF,aALyBA,EAAW1b,QAAQ2d,SAAS/B,EAAWhc,GAAQ2H,KAAK,CAC3EP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGlD,MAAO6E,GAEP,MADA9G,EAAeJ,2CAA2CkH,EAAEC,eAClDhI,2CAA2C+H,EAAEC,YAc9B+B,uBAC3BwO,EACAjL,EACAgY,EACAC,EACAC,EACAjL,EACAnM,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAIHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBge,WAAWH,EAAUC,EAAcC,EAAcjL,GACjD/L,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAYcvE,iBACrBwO,EACAjL,EACAgY,EACAC,EACAC,EACAjL,cAEA,MAAM4I,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGFqX,IACHA,EAAmB,CACjBmL,wBAAyB,6CACzBC,sBAAuB,6CACvBrJ,uBAAwB,MAI5B,MAAMsJ,QAAyBzC,EAAW1b,QAAQoe,yBAAyBne,OACrE0N,EAAS,CACb,CACEhO,MAAOoe,EAAaM,iBACpB/gB,UAAWygB,EAAaO,mBAE1B,CACE3e,MAAOmT,EAAiBoL,sBACxB5gB,UAAWihB,WAAWzL,EAAiB+B,yBAEzC,CACElV,MAAOwe,EAAiB,GACxB7gB,UAAWihB,WAAWJ,EAAiB,MAIrCK,EAAe,GACrB7Q,EAAO8Q,IAAK5Y,IACN2Y,EAAatkB,OAAS,EACxBskB,EAAaC,IAAKC,IACZA,EAAS/e,QAAUkG,EAAQlG,MAC7B+e,EAASphB,WAAauI,EAAQvI,UAE9BkhB,EAAa3Q,KAAK,CAChBlO,MAAOkG,EAAQlG,MACfrC,UAAWuI,EAAQvI,cAKzBkhB,EAAa3Q,KAAK,CAChBlO,MAAOkG,EAAQlG,MACfrC,UAAWuI,EAAQvI,cAKzB,MAAMqhB,EAA2BH,EAAaC,IAAInc,eAAO3C,GACvD,GAAIA,EAAMA,QAAUuF,GAAoC,IAApBvF,EAAMrC,UAAiB,OAAOqC,EAClE,MAAMif,QAAyBxX,EAAUyX,EAAK/iB,KAAM6D,EAAMA,MAAOkG,EAASgY,GAC1E,GACE,IAAIxW,EAAQuX,GAAkBtX,qBAAqB,IAAID,EAAQ1H,EAAMrC,YAGrE,MADA9D,EAAeJ,2CAA2CuG,EAAMA,aACtDpH,oBAAoBqmB,iBAG9B,OADAjf,EAAMif,iBAAmBA,EAClBjf,IAIX,UAC+BoI,QAAQ+W,IAAIH,GACzC,MAAOre,GAEP,MADA9G,EAAeJ,4CAA4CkH,SACjD/H,oCAAoC+H,KAGhD,IACE,MAAMuG,aAAoBkY,iBACxBjO,EACAjL,EACAgY,EACAC,EACAC,EACAjL,EACA4I,GAUF,aAPyBA,EAAW1b,QACjCge,WAAWH,EAAUC,EAAcC,EAAcjL,GACjDvL,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GAEP,MADA9G,EAAeJ,wCAAwCkH,EAAEC,eAC/ChI,gCAAgC+H,EAAEC,YAYX+B,+BACnCwO,EACAjL,EACAmZ,EACAvhB,EACAkJ,GAEA,MAAM+U,EACJ/U,GACA,SAAS7K,KAAKG,IAAI6D,SAAStH,KAAK4iB,wBAAyBtK,GAGrDlK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBif,mBAAmBD,EAAavhB,GAChCsJ,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAUsBvE,yBAC7BwO,EACAjL,EACAmZ,EACAvhB,GAEA,MAAMie,EAAa,SAAS5f,KAAKG,IAAI6D,SAAStH,KAAK4iB,wBAAyBtK,GAC5E,IACE,MAAMoO,EAAoB1hB,EAAkBC,GAEtCoJ,aAAoBsY,yBACxBrO,EACAjL,EACAmZ,EACAE,EACAxD,GAUF,aAPyBA,EAAW1b,QACjCif,mBAAmBD,EAAaE,GAChC3X,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GAEP,MADA9G,EAAeJ,sDAAsDkH,EAAEC,eAC7DhI,8CAA8C+H,EAAEC,YAYnB+B,qCACzCwO,EACAjL,EACAmZ,EACAxO,EACA7J,GAEA,MAAM+U,EACJ/U,GACA,SAAS7K,KAAKG,IAAI6D,SAAStH,KAAK4iB,wBAAyBtK,GAGrDlK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBof,yBAAyBJ,EAAaxO,GACtCzJ,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAU4BvE,+BACnCwO,EACAjL,EACAmZ,EACAxO,GAEA,MAAMkL,EAAa,SAAS5f,KAAKG,IAAI6D,SAAStH,KAAK4iB,wBAAyBtK,GAC5E,IACE,MAAMjK,aAAoBwY,+BACxBvO,EACAjL,EACAmZ,EACAxO,EACAkL,GAUF,aAPyBA,EAAW1b,QACjCof,yBAAyBJ,EAAaxO,GACtCjJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,MAAO6E,GAEP,MADA9G,EAAeJ,sDAAsDkH,EAAEC,eAC7DhI,8CAA8C+H,EAAEC,YAWpC+B,oBACxBwO,EACAjL,EACAyZ,EACA3Y,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBuf,QAAQD,GACRvY,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAWWvE,cAClBwO,EACAjL,EACAyZ,GAEA,eAAiBxE,gBAAgBhK,EAAWjL,GAC1C,UAAUtN,oCAGZ,MAAMmjB,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGDoL,aAAoB2Y,cAAc1O,EAAWjL,EAASyZ,EAAO5D,GASnE,aANyBA,EAAW1b,QAAQuf,QAAQD,GAAO/X,KAAK,CAC9DP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYjB6G,6BACjCwO,EACAjL,EACAc,GAEA,MAAM+U,EACJ/U,GACApL,EACE,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGHmL,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,QAAe6U,EAAW1b,QACvBiZ,mBACAlS,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EAUoBvE,uBAC3BwO,EACAjL,GAEA,cAAgB0V,IAAI5D,uBAAuByF,cAActM,MAAiBjL,EACxE,UAAUtN,MAAM,2BAElB,MAAMmjB,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGDoL,aAAoBqS,uBAAuBpI,EAAWjL,EAAS6V,GASrE,aANyBA,EAAW1b,QAAQiZ,mBAAmB1R,KAAK,CAClEP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAWvB6G,uBAACwO,EAAmBjL,GAC/C,MAAM6V,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,aADoBigB,EAAW1b,QAAQyf,YAAY5Z,GAAS5F,OAQ3CqC,aAACwO,GAClB,MAAM4K,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAED4B,QAAYqe,EAAW1b,QAAQ3C,MAAM4C,OAC3C,YAAYnE,KAAKqB,MAAM+M,QAAQ7M,GAOTiF,kBAACwO,GACvB,MAAM4K,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,aADuBigB,EAAW1b,QAAQD,WAAWE,OAQ7BqC,oBAACwO,GACzB,MAAM4K,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,aADyBigB,EAAW1b,QAAQ0f,mBAAmBzf,OASrCqC,sBAACwO,EAAmBjL,GAC9C,MAAM6V,EAAangB,EACjB,SAASO,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAerK,GAC/CtY,KAAKiD,QAGP,aAD8BigB,EAAW1b,QAAQ8a,gBAAgBjV,GAAS5F,OAUxDqC,cAACqQ,EAA0B9M,GAC7C,MAAM6V,EAAa,SAAS5f,KAAKG,IAAI6D,SAAStH,KAAK2iB,cAAexI,EAAkB,CAClF3L,KAAMnB,IAEF8B,QAAgB+T,EAAW1b,QAAQ4H,UAAU/B,GAAS5F,OAC5D,YAAYnE,KAAKqB,MAAM+M,QAAQvC,IC/1CnC,MAAMgY,GAAc,mDAIPC,GAcXvnB,YACEwe,EACA/a,EACAgb,EACArb,QAjBK0J,iBAAmB,SACnB0R,8BACAC,0BACAhb,iBACAL,mBACAokB,kBAcLrnB,KAAKqe,kBAAoBA,EACzBre,KAAKse,cAAgBA,GAAkBgJ,EAAqB7V,IAC5DzR,KAAKsD,KAAOA,EACZtD,KAAKiD,OAASA,GAAU6H,EAAqB,GAC7C9K,KAAKqnB,WAAatkB,EAChB,SAASO,KAAKG,IAAI6D,SAAStH,KAAKse,cAAete,KAAKqe,mBACpDre,KAAKiD,QAUmB6G,sBAACuD,EAAiBka,GAC5C,MAAMnZ,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5BggB,qBACCD,EAAQplB,KACRolB,EAAQnlB,OACRmlB,EAAQrjB,cACRijB,GACAA,GACAI,EAAQ9E,SACR8E,EAAQE,aACRF,EAAQ1hB,OAET0I,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASavE,gBAACuD,EAAiBka,GAGtC,GAFKA,EAAQrjB,gBAAeqjB,EAAQrjB,cAAgB,IAE/CqjB,EAAQplB,OAASolB,EAAQnlB,OAAQ,CACpC,MAAMD,KAAEA,EAAFC,OAAQA,GAAWnB,IACzBsmB,EAAQplB,KAAOA,EACfolB,EAAQnlB,OAASA,EAEnB,GAAImlB,EAAQrjB,yBAA4BwjB,6BACtC,UAAU3nB,qCAGZ,GAA8B,IAA1BwnB,EAAQrjB,cACV,UAAUnE,uCAEZ,IAAoE,gBAApD4nB,eAAeJ,EAAQrjB,gBAAgB8Y,SACrD,UAAUjd,gCAEZ,MAAMsO,aAAoBuZ,gBAAgBva,EAASka,GAG7CrY,aAAwBmY,WAAW7f,QACtCggB,qBACCD,EAAQplB,KACRolB,EAAQnlB,OACRmlB,EAAQrjB,cACRijB,GACAA,GACAI,EAAQ9E,SACR8E,EAAQE,aACRF,EAAQ1hB,OAETkJ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAGpD,IAAIgL,EAAe,KACnB,IACEA,EAAeiB,EAAW4P,OAAO+I,WAAW7I,aAAa,GACzD,MAAOlX,GACP9G,EAAeJ,6CAA6CkH,EAAEC,WAEhE,OAAOkG,EAMsBnE,2BAE7B,kBAD8Bud,WAAW7f,QAAQsgB,qBAAqBrgB,OAOvCqC,6BAE/B,kBAD8Bud,WAAW7f,QAAQugB,uBAAuBtgB,OAOrDqC,iBAEnB,kBAD8Bud,WAAW7f,QAAQ3B,QAAQ4B,OAOpBqC,mCAErC,kBADyBud,WAAW7f,QAAQkgB,6BAA6BjgB,OAOlCqC,qCAEvC,kBADyBud,WAAW7f,QAAQwgB,0BAA0BvgB,OAQ7CqC,qBAACb,GAC1B,GAAIA,aAAoBye,6BACtB,UAAU3nB,qCAGZ,GAAc,IAAVkJ,EACF,UAAUlJ,uCAGZ,kBAD4BsnB,WAAW7f,QAAQmgB,eAAe1e,GAAOxB,OAQ1CqC,uBAACb,GAE5B,kBAD4Boe,WAAW7f,QAAQygB,iBAAiBhf,GAAOxB,OAQ9CqC,qBAACwP,GAE1B,kBAD8B+N,WAAW7f,QAAQ0gB,UAAU5O,GAAW7R,OAQnDqC,eAAC0U,GAEpB,kBADkC6I,WAAW7f,QAAQ2gB,WAAW3J,GAAY/W,OAU7CqC,2BAC/BuD,EACA+a,GAEA,MAAMha,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5B6gB,oBAAoBD,GACpB7Z,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASkBvE,qBACzBuD,EACA+a,GAEA,cAAgBE,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAIqoB,IAAoBjB,GACtB,UAAUpnB,yCAGZ,MAAMsO,aAAoBka,qBAAqBlb,EAAS+a,GAWxD,kBAR8Bf,WAAW7f,QACtC6gB,oBAAoBD,GACpBrZ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYjB6G,+BACnCuD,EACAnJ,GAEA,MAAMkK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5BghB,wBAAwBtkB,GACxBqK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASsBvE,yBAC7BuD,EACAnJ,GAEA,cAAgBokB,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAImE,aAA4BwjB,6BAC9B,UAAU3nB,qCAGZ,GAAsB,IAAlBmE,EACF,UAAUnE,uCAEZ,MAAMsO,aAAoBoa,yBAAyBpb,EAASnJ,GAW5D,kBAR8BmjB,WAAW7f,QACtCghB,wBAAwBtkB,GACxB6K,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYd6G,kCACtCuD,EACAnJ,GAEA,MAAMkK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5BkhB,2BAA2BxkB,GAC3BqK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASyBvE,4BAChCuD,EACAnJ,GAEA,cAAgBokB,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAImE,aAA4BwjB,6BAC9B,UAAU3nB,qCAGZ,GAAsB,IAAlBmE,EACF,UAAUnE,uCAGZ,MAAMsO,aAAoBsa,4BAA4Btb,EAASnJ,GAW/D,kBAR8BmjB,WAAW7f,QACtCkhB,2BAA2BxkB,GAC3B6K,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYnB6G,6BACjCuD,EACA+a,GAEA,MAAMha,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5BohB,iBAAiBR,GACjB7Z,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAGX,OAAOC,EASoBvE,uBAC3BuD,EACA+a,GAEA,cAAgBE,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAIqoB,IAAoBjB,GACtB,UAAUpnB,yCAGZ,MAAMsO,aAAoBwa,uBAAuBxb,EAAS+a,GAW1D,kBAR8Bf,WAAW7f,QACtCohB,iBAAiBR,GACjBrZ,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYf6G,iCACrCuD,EACAnJ,GAEA,MAAMkK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5BshB,qBAAqB5kB,GACrBqK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EASwBvE,2BAC/BuD,EACAnJ,GAEA,cAAgBokB,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAImE,aAA4B6kB,+BAC9B,UAAUhpB,qCAGZ,GAAsB,IAAlBmE,EACF,UAAUnE,uCAEZ,IAA8D,gBAA9CkoB,iBAAiB/jB,IAAgB8Y,SAC/C,UAAUjd,sCAEZ,MAAMsO,aAAoB2a,2BAA2B3b,EAASnJ,GAW9D,kBAR8BmjB,WAAW7f,QACtCshB,qBAAqB5kB,GACrB6K,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAYZ6G,oCACxCuD,EACAnJ,GAEA,MAAMkK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5ByhB,wBAAwB/kB,GACxBqK,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAS2BvE,8BAClCuD,EACAnJ,GAEA,cAAgBokB,aAAgBjb,EAC9B,UAAUtN,qCAEZ,GAAImE,aAA4B6kB,+BAC9B,UAAUhpB,qCAGZ,GAAsB,IAAlBmE,EACF,UAAUnE,uCAEZ,IAA8D,gBAA9CkoB,iBAAiB/jB,IAAgB8Y,SAC/C,UAAUjd,oCAGZ,MAAMsO,aAAoB6a,8BAA8B7b,EAASnJ,GAWjE,kBAR8BmjB,WAAW7f,QACtCyhB,wBAAwB/kB,GACxB6K,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAWZ6G,oCACxCuD,EACA8b,GAEA,MAAM/a,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACEA,aAAoBgZ,WAAW7f,QAC5B4hB,wBAAwBD,GACxB5a,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAe2BvE,8BAClCuD,EACA8b,GAEA,GAAIA,EAAOznB,OAAS,GAClB,UAAU3B,yBAGZ,MAAMsO,aAAoBgb,8BAA8Bhc,EAAS8b,GAWjE,kBAR8B9B,WAAW7f,QACtC4hB,wBAAwBD,GACxBpa,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcjB6G,+BACnCuD,EACAic,EACArlB,GAGA,MAAMmK,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACE,MAAMkb,EAAgBvlB,EAAqBC,GAC3CoK,aAAoBgZ,WAAW7f,QAC5BgiB,mBAAmBF,EAAeC,GAClChb,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAYsBvE,yBAC7BuD,EACAic,EACArlB,GAEA,MAAMslB,EAAgBvlB,EAAqBC,GAErCoK,aAAoBob,yBAAyBpc,EAASic,EAAerlB,GAU3E,kBAR8BojB,WAAW7f,QACtCgiB,mBAAmBF,EAAeC,GAClCxa,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAcb6G,mCACvCuD,EACAic,EACArlB,EACAmC,GAEA,MAAMgI,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EACJ,IACE,MAAMkb,EAAgBvlB,EAAqBC,GACrCylB,QAAiBvjB,EAAsBnG,KAAKsD,KAAM8C,GACxDiI,aAAoBgZ,WAAW7f,QAC5BmiB,2BAA2BL,EAAeC,EAAeG,GACzDnb,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAa0BvE,6BACjCuD,EACAic,EACArlB,EACAmC,GAEA,MAAMiI,aAAoBub,6BACxBvc,EACAic,EACArlB,EACAmC,GAEImjB,EAAgBvlB,EAAqBC,GACrCylB,QAAiBvjB,EAAsBnG,KAAKsD,KAAM8C,GAWxD,kBAR8BihB,WAAW7f,QACtCmiB,2BAA2BL,EAAeC,EAAeG,GACzD3a,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAaR6G,wCAC5CuD,EACAic,EACArlB,EACAgB,GAEA,MAAMmJ,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EAEJ,MAAMkb,EAAgBvlB,EAAqBC,GACrC4lB,QAAkBtkB,EAAqBN,GAE7C,IACEoJ,aAAoBgZ,WAAW7f,QAC5BsiB,gCAAgCR,EAAeC,EAAeM,GAC9Dtb,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EAEX,OAAOC,EAa+BvE,kCACtCuD,EACAic,EACArlB,EACAgB,GAEA,MAAMskB,EAAgBvlB,EAAqBC,GACrC4lB,EAAYtkB,EAAqBN,GAEjCoJ,aAAoB0b,kCACxB1c,EACAic,EACArlB,EACAgB,GAYF,kBAR8BoiB,WAAW7f,QACtCsiB,gCAAgCR,EAAeC,EAAeM,GAC9D9a,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,UAaR6G,wCAC5CuD,EACAic,EACArlB,EACAwf,GAEA,MAAMrV,EAAkBpO,KAAK2M,iBAC7B,IAAI0B,EAEJ,MAAMkb,EAAgBvlB,EAAqBC,GAE3C,IACEoK,aAAoBgZ,WAAW7f,QAC5BwiB,gCAAgCV,EAAeC,EAAe9F,GAC9DlV,YAAY,CAAEC,KAAMnB,GAAW,CAACoB,EAAKJ,IAAYI,EAAML,EAAkBC,GAC5E,MAAOvG,GACPuG,EAASD,EACTpN,EAAeJ,MAAM,yDAA0DkH,GAEjF,OAAOuG,EAa+BvE,kCACtCuD,EACAic,EACArlB,EACAwf,GAEA,MAAM8F,EAAgBvlB,EAAqBC,GAE3Cwf,EAAgBrL,WAAa1T,EAAKC,MAAMC,MAAM6e,EAAgBrL,YAC9DqL,EAAgBtL,UAAYzT,EAAKC,MAAMC,MAAM6e,EAAgBtL,WAE7D,MAAM9J,aAAoB4b,kCACxB5c,EACAic,EACArlB,EACAwf,GAYF,kBAR8B4D,WAAW7f,QACtCwiB,gCAAgCV,EAAeC,EAAe9F,GAC9D1U,KAAK,CACJP,KAAMnB,EACN2B,IAAKX,EAAS,EACdY,eAAgB5L,EAAgBrD,KAAKsD,KAAMtD,KAAKiD,iBCv3B3CinB,sBAKJ7f,oBAMA8f,4BAMA/f,6BAMAE,wBAMA8f,yBAMA3f,8BAMAiB,iCAMA2e,8BAMAC,0BAMA9jB,gCAMA+jB,2BAMAC,oBAMA7f,qCAMA8f,wCAMA7f,6BAMA8f,yBAMA9e,qCAMAD,+BAMAd,uBAKA8f,oBAMAC,wBAMAC,gCAMAC,sBAEAC,sBAMP7gB,oBAMAC,oBAMAI,wBAMAC,wBAMAE,6BAMAxH,oCAMAC,0CAMAC,sCAMAO,+BChMWqnB,GAAWC,YACSA,EAAQ,GAAIC,GAC3C,MAAMpa,MAAEA,EAAFqa,OAASA,GAKjB,SACEF,EACAG,EACAC,GAEA,GAAqB,iBAAVJ,EAGT,MAFAjqB,EAAeV,MAAM,qBACrBU,EAAeV,MAAM2qB,OACXlrB,gEAAgEkrB,GAE5E,MAAM3hB,EAAQ2hB,EAAM3hB,MAfwB,yBAgB5C,OAAKA,EAIE,CAAEwH,OAAO,EAAMqa,OAAQ7hB,EAAM,KAHlCtI,EAAeN,wDACR,CAAEoQ,OAAO,EAAOqa,OAAQF,IAlBPK,CAAWL,GACrC,OAAQC,GAAcpa,EAAQ,KAAO,IAAMqa,EAHKI,CAAiBN,GAAO,SCyB7DO,GAKO1hB,mBAACQ,GACjB,IACE,MAAMmhB,QAAkB9hB,EAAQW,GAChC,aAAamhB,EAAUjb,OACvB,MAAO1I,GAEP,OADA9G,EAAeJ,MAAM,wCAAyCkH,SAKlE4jB,eACEC,EACAC,GAEA,OAAKD,EACEA,EAAkBvf,KAAMsB,GAAMA,EAAEke,cAAgBA,QAQzB9hB,0BAAC+hB,EAA0BJ,GACzD,MAAMK,EAAsC,GAC5C,IAAK,MAAM1W,KAAKqW,EAAUK,iBAMxBA,EAAiBzW,KALiB,CAChCuW,YAAaxW,EACb7M,OAAQkjB,EAAUK,iBAAiB1W,GAAG,GACtC2W,QAASF,EAAmBJ,EAAUK,iBAAiB1W,GAAG,KAI9D,OAAO0W,EAWYhiB,eACnBQ,EACA0hB,EACA1b,EACA2b,EACAH,GAEKG,IACHA,aAA+BC,aAAa5hB,IAEzCwhB,IACHA,aAA8BK,oBAAoB7hB,EAAa2hB,IAEjE,MAAM1b,EAAOvQ,KAAK0rB,eAAeI,EAAkB,SAC/C9rB,KAAK0rB,eAAeI,EAAkB,SAASC,QAC/C,KACJ,IAAKxb,EAAM,YACX,IACE,MAAMrH,QAAiBb,EAAMkI,kBAAuByb,IAAmB,CACrEzjB,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEV,aAAcpH,EAASsH,QAAQ4b,MAAMroB,WACrC,MAAO+D,GAEP,MADA9G,EAAeJ,MAAMkH,OACX/H,MAAM,wBAIQ+J,sBAC1BxG,EACA+oB,EACAC,GAGA,aADwB1f,EAAStJ,EAAM0nB,GAAQsB,GAAcD,GAI/BviB,0BAC9BxG,EACA+oB,EACAtkB,GAGA,aADwB6F,EAAatK,EAAMyE,EAASskB,GAUlCviB,cAClBL,EACAa,EACAgG,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEI1b,EAAOvQ,KAAK0rB,eAAeI,EAAkB,WAC/C9rB,KAAK0rB,eAAeI,EAAkB,WAAWC,QACjD,KACJ,IAAKxb,EAAM,YACX,IACE,MAAMrH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,OACRwB,KAAMiH,KAAKC,UAAUxH,GACrBL,QAAS,CACP,eAAgB,4BAElBkH,OAAQA,IAEV,aAAapH,EAASV,OACtB,MAAOV,GAEP,MADA9G,EAAeJ,MAAMkH,OACX/H,MAAM,wBAWM+J,oBACxBuG,EACAkc,EACAjiB,EACAgG,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEI9rB,EAAO,CAAEkQ,IAAKA,EAAKkc,UAAWA,GAC9BC,EAAwB,GACxBjc,EAAOvQ,KAAK0rB,eAAeI,EAAkB,YAC/C9rB,KAAK0rB,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKxb,EAAM,YACX,IACE,MAAMrH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,OACRwB,KAAMiH,KAAKC,UAAU9Q,GACrBiJ,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEJmc,QAAgCvjB,EAASsH,OAC/C,IAAK,MAAMpI,KAAUqkB,EACnBD,EAAMnX,KAAKjN,GAEb,OAAOokB,EACP,MAAO1kB,GACP,aAUqBgC,mBACvB5B,EACAoC,EACAgG,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEI9rB,EAAO,CAAE+H,IAAKA,EAAKxF,KAAM,OACzB8pB,EAAwB,GACxBjc,EAAOvQ,KAAK0rB,eAAeI,EAAkB,YAC/C9rB,KAAK0rB,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKxb,EAAM,YACX,IACE,MAAMrH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,OACRwB,KAAMiH,KAAKC,UAAU9Q,GACrBiJ,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEJmc,QAAgCvjB,EAASsH,OAC/C,IAAK,MAAMpI,KAAUqkB,EACnBD,EAAMnX,KAAKjN,GAEb,OAAOokB,EACP,MAAO1kB,GACP,aAO+BgC,6BACjCQ,EACAgG,SAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEI1b,WAAOvQ,KAAK0rB,eAAeI,EAAkB,+BAAtCY,EAA8DX,QAC3E,IAAKxb,EAAM,YACX,IACE,MAAMrH,QAAiBb,EAAMkI,EAAM,CACjChI,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,aADyCpH,EAASsH,OAElD,MAAO1I,GAEP,OADA9G,EAAeJ,MAAMkH,EAAEC,eAeJ+B,iBACrBuG,EACAkc,EACAI,EACAX,EACA1hB,EACAgG,EACAsc,EACAC,EACAC,GAEA,MAAMb,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEF,IAAIc,EAAgB/sB,KAAK0rB,eAAeI,EAAkB,cACtD9rB,KAAK0rB,eAAeI,EAAkB,cAAcC,QACpD,KAEJ,IAAKgB,EAAe,YACpBA,kBAAgC1c,IAChC0c,iBAA+BR,IAC/BQ,iBAA+BJ,IAC/BI,uBAAqCf,IACjCY,IACFG,GAAiB,aAAeC,UAAUhc,KAAKC,UAAU2b,KACvDC,IAAYE,GAAiB,gBAAkBC,UAAUH,IACzDC,IAAYC,GAAiB,eAAiBD,GAClD,IACE,MAAM5jB,QAAiBb,EAAM0kB,EAAe,CAC1CxkB,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,aAD0CpH,EAASsH,OAEnD,MAAO1I,GAEP,MADA9G,EAAeJ,MAAMkH,OACX/H,MAAM,0CAcO+J,qBACzBuG,EACAgc,EACAE,EACAI,EACAM,EACA3iB,EACAhH,EACAspB,GAEA,MAAMX,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEIiB,EAAcltB,KAAK0rB,eAAeI,EAAkB,YACtD9rB,KAAK0rB,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKmB,EAAa,YAClB,MAAMd,EAAQe,KAAKC,MAGnB,IAAIC,EAAaH,EAUjB,OATAG,iBAA4BV,IAC5BU,kBAA6Bhd,IAC7Bgd,oBAA+BJ,IAC/BI,iBAA4Bd,IAC5Bc,uBAAkChB,IAClCgB,aAAwBjB,IACxBiB,4BAT6BC,gBAAgBhqB,EAAM+oB,EAAWhc,EAAM+b,KAUhEQ,IACFS,GAAc,aAAeL,UAAUhc,KAAKC,UAAU2b,KACjDS,EAcgBvjB,mBACvBQ,EACAhH,EACA0oB,EACAa,EACAU,EACAC,EACAld,EACAmd,EACAtC,GAEA,MAAMc,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEIyB,EAAkB1tB,KAAK0rB,eAAeI,EAAkB,gBAC1D9rB,KAAK0rB,eAAeI,EAAkB,gBAAgBC,QACtD,KAEEK,EAAQe,KAAKC,MACnB,IAAIO,EAAmB3B,EACvB2B,GAAoBJ,EAAQK,WAC5BD,GAAoBvB,EACpB,MAAMyB,aAAuBC,oBAC3BxqB,EACA0oB,EACA2B,GAGI9jB,EAAUkkB,SAShB,GARAlkB,EAAQmiB,gBAAkBA,EAC1BniB,EAAQgkB,UAAYA,EACpBhkB,EAAQuiB,MAAQA,EAChBviB,EAAQmkB,YAAcnB,EACtBhjB,EAAQ0jB,QAAUA,EAClB1jB,EAAQ2jB,UAAYA,EAChB3jB,EAAQ4jB,qBAAoB5jB,EAAQ4jB,mBAAqBA,GACzDtC,IAAQthB,EAAQshB,OAASA,IACxBuC,EAAiB,YACtB,IACE,MAAMxkB,QAAiBb,EAAMqlB,EAAiB,CAC5CnlB,OAAQ,OACRwB,KAAMiH,KAAKC,UAAUpH,GACrBT,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,aAAIpH,GAAAA,EAAUZ,SACSY,EAASsH,QAGhCzP,QAAQH,MAAM,wBAAyBsI,EAASuH,OAAQvH,EAAS+kB,YACjEjtB,EAAeJ,MAAM,eAAgBiJ,SAErC,MAAO/B,GAIP,OAHA9G,EAAeJ,MAAM,yBACrBI,EAAeJ,MAAMkH,GACrB9G,EAAeJ,MAAM,eAAgBiJ,SAcjBC,kBACtBuG,EACA2b,EACAkC,EACA5jB,EACAhH,EACAgN,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEIkC,EAAiBnuB,KAAK0rB,eAAeI,EAAkB,eACzD9rB,KAAK0rB,eAAeI,EAAkB,eAAeC,QACrD,KAEEK,aAAmBgC,SACvB9jB,EACA0hB,EACA1b,EACA2b,EACAH,GAGF,IAAI6B,EAAmB3B,EACvB2B,GAAoBO,GAAS,GAC7BP,GAAqBtd,MAAU2a,GAAQ3a,MAAW,GAClDsd,GAAoBvB,EACpB,MAAMyB,aAAuBC,oBAC3BxqB,EACA0oB,EACA2B,GAGI9jB,EAAUkkB,SAMhB,GALAlkB,EAAQgkB,UAAYA,EACpBhkB,EAAQ+jB,WAAa5C,GAAQ3a,GAC7BxG,EAAQmiB,gBAAkBA,EACtBkC,IAAOrkB,EAAQqkB,MAAQA,IAEtBC,EAAgB,YACrB,IACE,MAAMjlB,QAAiBb,EAAM8lB,EAAgB,CAC3C5lB,OAAQ,MACRwB,KAAMiH,KAAKC,UAAUpH,GACrBT,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,aAAIpH,GAAAA,EAAUZ,SACSY,EAASsH,QAGhCxP,EAAeJ,MAAM,uBAAwBsI,EAASuH,OAAQvH,EAAS+kB,YACvEjtB,EAAeJ,MAAM,eAAgBiJ,SAErC,MAAO/B,GAIP,OAHA9G,EAAeJ,MAAM,wBACrBI,EAAeJ,MAAMkH,GACrB9G,EAAeJ,MAAM,eAAgBiJ,SAafC,oBACxBQ,EACA0hB,EACAkC,EACA7d,EACAC,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEIoC,EAAmBruB,KAAK0rB,eAAeI,EAAkB,iBAC3D9rB,KAAK0rB,eAAeI,EAAkB,iBAAiBC,QACvD,KAEJ,IAAI7jB,sBAA0B8jB,IAI9B,GAHA9jB,GAAQmI,kBAAsB2a,GAAQ3a,MAAW,GACjDnI,GAAQgmB,aAAmBA,KAAY,IAElCG,EAAkB,YACvB,IACE,MAAMnlB,QAAiBb,EAAMgmB,EAAmBnmB,EAAK,CACnDK,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEV,aAAIpH,GAAAA,EAAUZ,SACSY,EAASsH,QAGhCxP,EAAeJ,MACb,6BACAsI,EAASuH,OACTvH,EAAS+kB,kBAGX,MAAOnmB,GAGP,OAFA9G,EAAeJ,MAAM,6BACrBI,EAAeJ,MAAMkH,SAcOgC,0BAC9BQ,EACAhH,EACA0oB,EACAkC,EACAjlB,GAEA,MAAMgjB,aAA+BC,aAAa5hB,GAClDvJ,QAAQP,IAAI,oCAAqCyrB,GACjD,MAAMH,aAA8BK,oBAClC7hB,EACA2hB,GAEFlrB,QAAQP,IAAI,mCAAoCsrB,GAChD,MAAMwC,EAAmBtuB,KAAK0rB,eAAeI,EAAkB,iBAC3D9rB,KAAK0rB,eAAeI,EAAkB,iBAAiBC,QACvD,KAEJhrB,QAAQP,IAAI,mCAAoC8tB,GAChD,MAAMlC,EAAQe,KAAKC,MACnB,IAAIO,EAAmB3B,EACvB2B,GAAoBO,EACpBP,GAAoB1kB,EAAMlF,WAC1B4pB,GAAoBvB,EACpB,MAAMyB,aAAuBC,oBAC3BxqB,EACA0oB,EACA2B,GAGF,IAAIY,EAAYD,EAQhB,OAPAC,uBAAiCvC,IACjCuC,aAAuBL,IACvBK,aAAuBtlB,EAAMlF,aAC7BwqB,aAAuBnC,IACvBmC,GAAcV,iBAA2BA,KAAgB,GAEzD9sB,QAAQP,IAAI,4BAA6B+tB,GACpCA,QAamBzkB,oBACxBuG,EACA2b,EACAkC,EACA5jB,EACAhH,EACAgN,GAEA,MAAM2b,aAA+BC,aAAa5hB,GAC5CwhB,aAA8BK,oBAClC7hB,EACA2hB,GAEIuC,EAAmBxuB,KAAK0rB,eAAeI,EAAkB,iBAC3D9rB,KAAK0rB,eAAeI,EAAkB,iBAAiBC,QACvD,KAEEK,aAAmBgC,SACvB9jB,EACA0hB,EACA1b,EACA2b,EACAH,GAGF,IAAI6B,EAAmB3B,EACvB2B,GAAoBO,GAAS,GAC7BP,GAAqBtd,MAAU2a,GAAQ3a,MAAW,GAClDsd,GAAoBvB,EACpB,MAAMyB,aAAuBC,oBAC3BxqB,EACA0oB,EACA2B,GAGI9jB,EAAUkkB,SAMhB,GALAlkB,EAAQ+jB,WAAa5C,GAAQ3a,GAC7BxG,EAAQmiB,gBAAkBA,EAC1BniB,EAAQqkB,MAAQA,EACZL,IAAWhkB,EAAQgkB,UAAYA,IAE9BW,EAAkB,YACvB,IACE,MAAMtlB,QAAiBb,EAAMmmB,EAAkB,CAC7CjmB,OAAQ,SACRwB,KAAMiH,KAAKC,UAAUpH,GACrBT,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAGV,aAAIpH,GAAAA,EAAUZ,SACSY,EAASsH,QAGhCxP,EAAeJ,MACb,6BACAsI,EAASuH,OACTvH,EAAS+kB,YAEXjtB,EAAeJ,MAAM,eAAgBiJ,SAErC,MAAO/B,GAIP,OAHA9G,EAAeJ,MAAM,8BACrBI,EAAeJ,MAAMkH,GACrB9G,EAAeJ,MAAM,eAAgBiJ,SAUbC,sBAAC5B,EAAaoI,GACxC,IACE,MAAMpH,QAAiBb,EAAMH,EAAK,CAChCK,OAAQ,MACRa,QAAS,CACP,eAAgB,oBAElBkH,OAAQA,IAEV,SAAIpH,GAAAA,EAAUZ,GAAI,CAChB,MAAMmmB,QAAevlB,EAASsH,OAC9B,GAAIie,GAAUA,EAAOtE,gBAAiB,SAExC,SACA,MAAOvpB,GAEP,OADAI,EAAeJ,oCAAoCA,EAAMmH,gBAMlD2mB,MAAAA,GAAmB,IAAIlD"}