{"version":3,"file":"lib.umd.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/Constants.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts","../src/models/Config.ts","../src/utils/DdoHelpers.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { Config } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  const contractConfig = `contract config ${config?.transactionBlockTimeout} , ${config?.transactionConfirmationBlocks} , ${config?.transactionPollingTimeout}`\n  console.log('contractConfig: ', contractConfig)\n  const contractValue = `contract value ${contract?.transactionBlockTimeout} , ${contract?.transactionConfirmationBlocks} , ${contract?.transactionPollingTimeout}`\n  console.log(contractValue)\n  return contract\n}\n\nexport async function getFairGasPrice(web3: Web3, config: Config): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  console.log(`getFairGasPrice ${config?.gasFeeMultiplier}`)\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport function getFreOrderParams(freParams: FreOrderParams): any {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: Web3.utils.toWei(freParams.maxBaseTokenAmount),\n    swapMarketFee: Web3.utils.toWei(freParams.swapMarketFee),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer)\n    freParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = await tokenContract.methods.decimals().call()\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const anchor = document.createElement('a')\n  anchor.download = ''\n  anchor.href = url\n  anchor.click()\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signText(\n  web3: Web3,\n  text: string,\n  publicKey: string,\n  password?: string\n): Promise<string> {\n  const isMetaMask =\n    web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n  try {\n    return await web3.eth.personal.sign(text, publicKey, password)\n  } catch (e) {\n    if (isMetaMask) {\n      throw e\n    }\n    LoggerInstance.warn('Error on personal sign.')\n    LoggerInstance.warn(e)\n    try {\n      return await web3.eth.sign(text, publicKey)\n    } catch (e2) {\n      LoggerInstance.error('Error on sign.')\n      LoggerInstance.error(e2)\n      throw new Error('Error executing personal sign')\n    }\n  }\n}\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n\nexport async function signWithHash(\n  web3: Web3,\n  text: string,\n  publicKey: string,\n  password?: string\n): Promise<string> {\n  const hash = web3.utils.utf8ToHex(text)\n  const isMetaMask =\n    web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n  try {\n    return await web3.eth.personal.sign(hash, publicKey, password)\n  } catch (e) {\n    if (isMetaMask) {\n      throw e\n    }\n    LoggerInstance.warn('Error on personal sign.')\n    LoggerInstance.warn(e)\n    try {\n      return await web3.eth.sign(hash, publicKey)\n    } catch (e2) {\n      LoggerInstance.error('Error on sign.')\n      LoggerInstance.error(e2)\n      throw new Error('Error executing personal sign')\n    }\n  }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport { amountToUnits, getFairGasPrice, unitsToAmount } from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { GASLIMIT_DEFAULT } from '.'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  const gasLimitDefault = GASLIMIT_DEFAULT\n  let estGas\n  try {\n    estGas = await tokenContract.methods\n      .approve(spender, amount)\n      .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n  } catch (e) {\n    estGas = gasLimitDefault\n    LoggerInstance.error('estimate gas failed for approve!', e)\n  }\n  return estGas\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount  (always expressed as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowence\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await estApprove(\n    web3,\n    account,\n    tokenAddress,\n    spender,\n    amountFormatted,\n    tokenContract\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERRPR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt)\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(3.01)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2.01)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  private config: Config\n\n  constructor(web3: Web3, poolAbi: AbiItem | AbiItem[] = null, config?: Config) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .setSwapFee(fee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estSetSwapFee(account, poolAddress, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get OPC Collector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getOPCCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {String}\n   */\n  async getReserve(poolAddress: string, token: string): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getMarketFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @return {String}\n   */\n  async getCommunityFees(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await unitsToAmount(this.web3, token, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectOPC()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectOPC(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectMarketFee()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectMarketFee(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .updatePublishMarketFee(newPublishMarketAddress, newPublishMarketSwapFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estUpdatePublishMarketFee(\n      address,\n      poolAddress,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountIn(\n      address,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const tokenAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn\n    )\n\n    const minAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut\n    )\n\n    let result = null\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountOut(\n      account,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const maxAmountIn = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn\n    )\n\n    const tokenAmountOut = await amountToUnits(\n      this.web3,\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? amountToUnits(\n          this.web3,\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinPool method\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinPool(poolAmountOut, maxAmountsIn)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Adds dual side liquidity to the pool (both datatoken and basetoken)\n   * This will pull some of each of the currently trading tokens in the pool,\n   * meaning you must have called approve for each token for this pool.\n   * These values are limited by the array of maxAmountsIn in the order of the pool tokens.\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} poolAmountOut expected number of pool shares that you will get\n   * @param {String[]} maxAmountsIn array with maxium amounts spent\n   * @return {TransactionReceipt}\n   */\n  async joinPool(\n    address: string,\n    poolAddress: string,\n    poolAmountOut: string,\n    maxAmountsIn: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMaxAmountsIn = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], maxAmountsIn[i])\n      weiMaxAmountsIn.push(amount)\n    }\n\n    let result = null\n\n    const estGas = await this.estJoinPool(\n      address,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountOut),\n      weiMaxAmountsIn\n    )\n\n    try {\n      result = await pool.methods\n        .joinPool(this.web3.utils.toWei(poolAmountOut), weiMaxAmountsIn)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to join pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitPool\n   * @param {String} address\n   * @param {String} poolAddress\n ``* @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut  aarray with minimum amount of tokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitPool(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[],\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitPool(poolAmountIn, minAmountsOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes dual side liquidity from the pool (both datatoken and basetoken)\n   * Exit the pool, paying poolAmountIn pool tokens and getting some of each of the currently trading tokens in return.\n   * These values are limited by the array of minAmountsOut in the order of the pool tokens.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn amount of pool shares spent\n   * @param {String[]} minAmountsOut array with minimum amount of tokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitPool(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minAmountsOut: string[]\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    const weiMinAmountsOut = []\n    const tokens = await this.getFinalTokens(poolAddress)\n\n    for (let i = 0; i < 2; i++) {\n      const amount = await amountToUnits(this.web3, tokens[i], minAmountsOut[i])\n      weiMinAmountsOut.push(amount)\n    }\n    let result = null\n    const estGas = await this.estExitPool(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      weiMinAmountsOut\n    )\n\n    try {\n      result = await pool.methods\n        .exitPool(this.web3.utils.toWei(poolAmountIn), weiMinAmountsOut)\n        .send({\n          from: account,\n          gas: estGas,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to exit pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinswapExternAmountIn(tokenAmountIn, minPoolAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n    const estGas = await this.estJoinswapExternAmountIn(\n      account,\n      poolAddress,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitswapPoolAmountIn(poolAmountIn, minTokenAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await amountToUnits(\n      this.web3,\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut\n    )\n    const estGas = await this.estExitswapPoolAmountIn(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenIn)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountIn),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param _consumeMarketSwapFee consume market swap fee\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await unitsToAmount(this.web3, tokenOut, result.tokenAmountOut),\n        liquidityProviderSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.lpFeeAmount\n        ),\n        oceanFeeAmount: await unitsToAmount(this.web3, tokenIn, result.oceanFeeAmount),\n        publishMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.publishMarketSwapFeeAmount\n        ),\n        consumeMarketSwapFeeAmount: await unitsToAmount(\n          this.web3,\n          tokenIn,\n          result.consumeMarketSwapFeeAmount\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await amountToUnits(this.web3, tokenIn, tokenAmountIn)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await amountToUnits(this.web3, poolAddress, poolAmountOut)\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n\n        .call()\n\n      amount = await unitsToAmount(this.web3, tokenIn, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await amountToUnits(this.web3, poolAddress, poolAmountIn)\n        )\n        .call()\n      amount = await unitsToAmount(this.web3, tokenOut, result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await amountToUnits(this.web3, tokenOut, tokenAmountOut)\n        )\n        .call()\n\n      amount = await unitsToAmount(this.web3, poolAddress, result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_SWAP' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_JOIN' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_EXIT' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public GASLIMIT_DEFAULT = 1000000\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.dispenserContract.methods\n        .create(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance),\n          address,\n          allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreate(\n      dtAddress,\n      address,\n      maxTokens,\n      maxBalance,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasActivate(dtAddress, maxTokens, maxBalance, address)\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .deactivate(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasDeactivate(dtAddress, address)\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasSetAllowedSwapper(\n        dtAddress,\n        address,\n        newAllowedSwapper\n      )\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasDispense(dtAddress, address, amount, destination)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasOwnerWithdraw(dtAddress, address)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  configHelperNetworks,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  public GASLIMIT_DEFAULT = 1000000\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public fixedRateContract: Contract\n  public web3: Web3\n  public contract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    console.log('contract FRE config ')\n    console.log(this.config)\n    this.contract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(token: string, amount: string): Promise<string> {\n    return amountToUnits(this.web3, token, amount)\n  }\n\n  async unitsToAmount(token: string, amount: string): Promise<string> {\n    return unitsToAmount(this.web3, token, amount)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .buyDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = '0x0000000000000000000000000000000000000000',\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount\n    )\n\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .sellDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = '0x0000000000000000000000000000000000000000',\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount\n    )\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, await this.web3.utils.toWei(newRate))\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(address, exchangeId, newRate)\n    const trxReceipt = await this.contract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, newAllowedSwapper)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetAllowedSwapper(address, exchangeId, newAllowedSwapper)\n    const trxReceipt = await this.contract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n\n    const estGas = await this.estActivate(address, exchangeId)\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).datatoken,\n      dtSupply\n    )\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      btSupply\n    )\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const configValue = `${this.contract?.transactionBlockTimeout} , ${this.contract?.transactionConfirmationBlocks} , ${this.contract?.transactionPollingTimeout}`\n    console.log(\n      `contract calcBaseInGivenOutDT config ${this.contract?.transactionBlockTimeout} , ${this.contract?.transactionConfirmationBlocks} , ${this.contract?.transactionPollingTimeout}`\n    )\n    console.log('contractConfig: ', configValue)\n    LoggerInstance.log(\n      `contract calcBaseInGivenOutDT config log : ${this.contract?.transactionBlockTimeout} , ${this.contract?.transactionConfirmationBlocks} , ${this.contract?.transactionPollingTimeout}`\n    )\n    const result = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(fixedRateExchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(exchange.datatoken, datatokenAmount),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result[0]\n    )\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(result.datatoken, result.dtBalance)\n    result.btBalance = await this.unitsToAmount(result.baseToken, result.btBalance)\n    result.dtSupply = await this.unitsToAmount(result.datatoken, result.dtSupply)\n    result.btSupply = await this.unitsToAmount(result.baseToken, result.btSupply)\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    result.marketFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.marketFeeAvailable\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      (\n        await this.getExchange(exchangeId)\n      ).baseToken,\n      result.oceanFeeAvailable\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.contract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId, true)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await this.estActivateMint(address, exchangeId)\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectBT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectBT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.baseToken, amount)\n    const trxReceipt = await this.contract.methods.collectBT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    try {\n      estGas = await fixedRate.methods\n        .collectDT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectDT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(fixedrate.datatoken, amount)\n    const trxReceipt = await this.contract.methods.collectDT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectMarketFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectMarketFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectOceanFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectOceanFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFee(exchangeId, newMarketFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(\n      address,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estUpdateMarketFeeCollector(\n      address,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  configHelperNetworks\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(web3: Web3, nftAbi?: AbiItem | AbiItem[], config?: Config) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .createERC20(\n          templateIndex,\n          [name, symbol],\n          [minter, paymentCollector, mpFeeAddress, feeToken],\n          [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n          []\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCreateErc20(\n      nftAddress,\n      address,\n      minter,\n      paymentCollector,\n      mpFeeAddress,\n      feeToken,\n      feeAmount,\n      cap,\n      name,\n      symbol,\n      templateIndex,\n      nftContract\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasAddManager(nftAddress, address, manager, nftContract)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasRemoveManager(\n      nftAddress,\n      address,\n      manager,\n      nftContract\n    )\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToCreateERC20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await this.estGasAddErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromCreateErc20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await this.estGasRemoveErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addTo725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFrom725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await this.estGasRemoveStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasCleanPermissions(nftAddress, address, nftContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .transferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .safeTransferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasSafeTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaData(\n          metadataState,\n          metadataDecryptorUrl,\n          metadataDecryptorAddress,\n          flags,\n          data,\n          metadataHash,\n          metadataProofs\n        )\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      LoggerInstance.error('estGasSetMetadata error: ', e.message)\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadata(\n      nftAddress,\n      address,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs,\n      nftContract\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadataAndTokenURI(\n      nftAddress,\n      metadataUpdater,\n      metadataAndTokenURI,\n      nftContract\n    )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataState(metadataState)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await this.estGasSetMetadataState(nftAddress, address, metadataState)\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setTokenURI('1', data)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estSetTokenURI(nftAddress, address, data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.getData(key).call()\n    return data\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  configHelperNetworks,\n  getFreOrderParams,\n  allowance,\n  ZERO_ADDRESS\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public GASLIMIT_DEFAULT = 1000000\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || configHelperNetworks[0]\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for mint method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .approve(spender, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasApprove(\n      dtAddress,\n      spender,\n      amount,\n      address,\n      dtContract\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    if (!fixedRateParams.allowedConsumer)\n      fixedRateParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createFixedRate(\n          fixedRateParams.fixedRateAddress,\n          [\n            fixedRateParams.baseTokenAddress,\n            address,\n            fixedRateParams.marketFeeCollector,\n            fixedRateParams.allowedConsumer\n          ],\n          [\n            fixedRateParams.baseTokenDecimals,\n            fixedRateParams.datatokenDecimals,\n            fixedRateParams.fixedRate,\n            fixedRateParams.marketFee,\n            withMint\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer)\n      fixedRateParams.allowedConsumer = '0x0000000000000000000000000000000000000000'\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateFixedRate(\n      dtAddress,\n      address,\n      fixedRateParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper)\n      dispenserParams.allowedSwapper = '0x0000000000000000000000000000000000000000'\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createDispenser(\n          dispenserAddress,\n          dispenserParams.maxTokens,\n          dispenserParams.maxBalance,\n          dispenserParams.withMint,\n          dispenserParams.allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper)\n      dispenserParams.allowedSwapper = '0x0000000000000000000000000000000000000000'\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateDispenser(\n      dtAddress,\n      address,\n      dispenserAddress,\n      dispenserParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await this.estGasMint(\n        dtAddress,\n        address,\n        amount,\n        toAddress,\n        dtContract\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for addMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await this.estGasAddMinter(dtAddress, address, minter, dtContract)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    // Estimate gas for removeMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removeMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemoveMinter(dtAddress, address, minter, dtContract)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for addFeeManager method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addPaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasAddPaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removePaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemovePaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setPaymentCollector(paymentCollector)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager =\n      (await this.getDTPermissions(dtAddress, address)).paymentManager === true\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await this.estGasSetPaymentCollector(\n      dtAddress,\n      address,\n      paymentCollector,\n      dtContract\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .transfer(toAddress, amount)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasTransfer(\n        dtAddress,\n        toAddress,\n        amount,\n        address,\n        dtContract\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: '0x0000000000000000000000000000000000000000',\n        consumeMarketFeeToken: '0x0000000000000000000000000000000000000000',\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await this.estGasStartOrder(\n        dtAddress,\n        address,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n    try {\n      const freContractParams = getFreOrderParams(freParams)\n\n      const estGas = await this.estGasBuyFromFreAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        freContractParams,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n    try {\n      const estGas = await this.estGasBuyFromDispenserAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        dispenserContract,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setData(value)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasSetData(dtAddress, address, value, dtContract)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(value).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCleanPermissions(dtAddress, address, dtContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  configHelperNetworks,\n  setContractDefaults\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\nconst addressZERO = '0x0000000000000000000000000000000000000000'\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || configHelperNetworks[0]\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .deployERC721Contract(\n          nftData.name,\n          nftData.symbol,\n          nftData.templateIndex,\n          addressZERO,\n          addressZERO,\n          nftData.tokenURI,\n          nftData.transferable,\n          nftData.owner\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await this.estGasCreateNFT(address, nftData)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        addressZERO,\n        addressZERO,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .add721TokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === addressZERO) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await this.estGasAddNFTTemplate(address, templateAddress)\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disable721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await this.estGasDisableNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivate721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await this.estGasReactivateNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .addTokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === addressZERO) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await this.estGasAddTokenTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disableTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await this.estGasDisableTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivateTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await this.estGasReactivateTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .startMultipleTokenOrder(orders)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await this.estGasStartMultipleTokenOrder(address, orders)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    // Get estimated gas value\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20(nftCreateData, ercCreateData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await this.estGasCreateNftWithErc20(address, nftCreateData, ercParams)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      const poolData = await getPoolCreationParams(this.web3, poolParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreateNftErc20WithPool(\n      address,\n      nftCreateData,\n      ercParams,\n      poolParams\n    )\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await this.estGasCreateNftErc20WithFixedRate(\n      address,\n      nftCreateData,\n      ercParams,\n      freParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n      LoggerInstance.error('Failed to estimate gas for createNftErc20WithDispenser', e)\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await this.estGasCreateNftErc20WithDispenser(\n      address,\n      nftCreateData,\n      ercParams,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData, downloadFile, downloadFileBrowser } from '../utils'\nimport {\n  FileMetadata,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport { signText, signWithHash } from '../utils/SignatureUtils'\nimport fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types/DownloadResponse'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async createSignature(\n    web3: Web3,\n    accountId: string,\n    agreementId: string\n  ): Promise<string> {\n    const signature = await signText(web3, noZeroX(agreementId), accountId)\n    return signature\n  }\n\n  public async createHashSignature(\n    web3: Web3,\n    accountId: string,\n    message: string\n  ): Promise<string> {\n    const signature = await signWithHash(web3, message, accountId)\n    return signature\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url' }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.createSignature(web3, accountId, did + nonce)\n\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      console.error('Compute start failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @param {AbortSignal} signal Abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    console.log('computeResult computeResultUrl: ', computeResultUrl)\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n\n    console.log('computeResult resultUrl: ', resultUrl)\n    if (!resultUrl) return null\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.createHashSignature(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n}\n\nexport default Config\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n"],"names":["LogLevel","Logger","logLevel","Error","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","amountToUnits","web3","token","amount","tokenContract","eth","Contract","methods","decimals","call","BigNumber","config","EXPONENTIAL_AT","times","exponentiatedBy","toString","e","message","unitsToAmount","amountFormatted","div","getPoolCreationParams","poolParams","ssContract","baseTokenAddress","baseTokenSender","publisherAddress","marketFeeCollector","poolTemplateAddress","vestedBlocks","Web3","utils","toWei","vestingAmount","baseTokenDecimals","rate","initialBaseTokenLiquidity","addresses","ssParams","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","getFairGasPrice","getGasPrice","x","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getErcCreationParams","ercParams","templateIndex","strings","minter","paymentCollector","mpFeeAddress","feeToken","uints","cap","feeAmount","bytess","getFreOrderParams","freParams","exchangeContract","exchangeId","maxBaseTokenAmount","swapMarketFee","marketFeeAddress","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","owner","datatokenDecimals","fixedRate","marketFee","getData","url","fetch","method","headers","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","erc721FactoryAddress","ERC721Factory","sideStakingAddress","Staking","opfCommunityFeeCollector","OPFCommunityFeeCollector","poolTemplate","FixedPrice","Dispenser","Ocean","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","ZERO_ADDRESS","GASLIMIT_DEFAULT","signWithHash","text","publicKey","password","hash","utf8ToHex","isMetaMask","currentProvider","personal","sign","e2","signText","balance","allowance","tokenAddress","account","spender","trxReceipt","estApprove","contractInstance","estGas","gasLimitDefault","approve","estimateGas","from","err","sleep","ms","Promise","resolve","setTimeout","getMaxRemoveLiquidity","poolInstance","poolAddress","getReserve","calcMaxExactIn","getMaxAddLiquidity","getMaxSwapExactIn","getMaxSwapExactOut","calcMaxExactOut","Decimal","bind","pact","_settle","result","Aquarius","aquariusURL","did","signal","path","response","ok","json","status","waitForAqua","txid","tries","_this4","ddo","event","validate","jsonResponse","valid","_this6","body","JSON","stringify","proof","validatorAddress","r","s","v","errors","MaxUint256","prototype","state","update","_isSettledPact","_resumeAfterBody","reject","_resumeAfterTest","Pool","poolAbi","PoolTemplate","abi","sharesBalance","_this2","balanceOf","fromWei","estSetSwapFee","fee","poolContract","defaultErc20Abi","setSwapFee","pool","_pool$methods$setSwap2","send","gas","gasPrice","getNumTokens","_this8","getPoolSharesTotalSupply","_this10","totalSupply","getCurrentTokens","_this12","getFinalTokens","_this14","getController","_this16","getBaseToken","_this18","getBaseTokenAddress","getDatatoken","_this20","getDatatokenAddress","getMarketFee","_this22","getMarketFeeCollector","_this24","_publishMarketCollector","getOPCCollector","_this26","_opcCollector","isBound","_this28","_this30","getBalance","isFinalized","_this32","getSwapFee","_this34","getNormalizedWeight","_this36","weight","getDenormalizedWeight","_this38","getTotalDenormalizedWeight","_this40","getMarketFees","_this42","publishMarketFees","getCurrentMarketFees","_this44","getCurrentOPCFees","_this46","getCommunityFees","_this48","communityFees","estCollectOPC","address","_this50","collectOPC","_this52","_pool$methods$collect2","estCollectMarketFee","_this54","collectMarketFee","_this56","_this55$getMarketFeeC","_pool$methods$collect4","estUpdatePublishMarketFee","newPublishMarketAddress","newPublishMarketSwapFee","_this58","updatePublishMarketFee","_this60","_this59$getMarketFeeC","_pool$methods$updateP2","estSwapExactAmountIn","tokenInOutMarket","amountsInOutMaxFee","_this62","tokenIn","tokenAmountIn","tokenOut","minAmountOut","maxPrice","_amountsInOutMaxFee$m","swapExactAmountIn","_this64","maxSwap","greaterThan","_pool$methods$swapExa2","estSwapExactAmountOut","_this66","maxAmountIn","tokenAmountOut","swapExactAmountOut","_this68","_amountsInOutMaxFee$m4","_pool$methods$swapExa4","estJoinPool","poolAmountOut","maxAmountsIn","_this70","joinPool","_this72","weiMaxAmountsIn","tokens","_pool$methods$joinPoo2","i","push","estExitPool","poolAmountIn","minAmountsOut","_this74","exitPool","_this76","weiMinAmountsOut","_pool$methods$exitPoo2","estJoinswapExternAmountIn","minPoolAmountOut","_this78","joinswapExternAmountIn","_this80","amountInFormatted","_pool$methods$joinswa2","estExitswapPoolAmountIn","minTokenAmountOut","_this82","exitswapPoolAmountIn","_this84","calcSingleOutGivenPoolIn","minTokenOutFormatted","_pool$methods$exitswa2","getSpotPrice","decimalsDiff","decimalsTokenIn","decimalsTokenOut","price","_this86","tokenOutContract","tokenInContract","getAmountInExactOut","_this88","amountOutFormatted","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","tokenAmount","liquidityProviderSwapFeeAmount","getAmountOutExactIn","_this90","calcPoolOutGivenSingleIn","_this92","_pool$methods","calcPoolOutSingleIn","_calcPoolOutSingleIn","calcSingleInGivenPoolOut","_this94","calcSingleInPoolOut","_this96","_pool$methods2","calcSingleOutPoolIn","_calcSingleOutPoolIn","calcPoolInGivenSingleOut","_this98","_pool$methods3","calcPoolInSingleOut","_calcPoolInSingleOut","getSwapEventSignature","eventdata","o","encodeEventSignature","getJoinEventSignature","getExitEventSignature","FixedRateCreateProgressStep","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","maxTokens","maxBalance","_exit2","logger","estGasCreate","dtAddress","allowedSwapper","create","_this5$dispenserContr","estGasActivate","activate","_this9$dispenserContr","estGasDeactivate","deactivate","_this13$dispenserCont","estGasSetAllowedSwapper","newAllowedSwapper","setAllowedSwapper","_this17$dispenserCont","estGasDispense","destination","dispense","_this21$dispenserCont","estGasOwnerWithdraw","ownerWithdraw","_this25$dispenserCont","isDispensable","datatoken","active","greaterThanOrEqualTo","String","isMinter","recover","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","generateExchangeId","baseToken","estBuyDT","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","getExchange","exchange","consumeMarketFeeFormatted","dtAmountFormatted","maxBtFormatted","_this9$contract$metho","estSellDT","sellDT","minBaseTokenAmount","minBtFormatted","_this13$contract$meth","getNumberOfExchanges","estSetRate","newRate","_fixedRate$methods","setRate","_setRate","_this19$contract$meth","estSetAllowedSwapper","_this23$contract$meth","estActivate","toggleExchangeState","_this27$contract$meth","estDeactivate","_this31$contract$meth","getRate","weiRate","getDTSupply","dtSupply","_this35$getExchange","getBTSupply","btSupply","_this37$getExchange","getAllowedSwapper","calcBaseInGivenOutDT","fixedRateExchange","configValue","_this42$contract","_this42$contract2","_this42$contract3","_this42$contract4","_this42$contract5","_this42$contract6","_this42$contract7","_this42$contract8","_this42$contract9","_this41$contract$meth","_calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","getAmountBTOut","_this43$contract$meth","calcBaseOutGivenInDT","_calcBaseOutGivenInDT","_this43$getExchange","dtDecimals","btDecimals","dtBalance","btBalance","getFeesInfo","opcFee","_this47$getExchange2","marketFeeAvailable","_this47$getExchange","oceanFeeAvailable","getExchanges","isActive","estActivateMint","toggleMintState","activateMint","_this55$contract$meth","estDeactivateMint","deactivateMint","_this59$contract$meth","estCollectBT","fixedrate","amountWei","collectBT","_this63$contract$meth","estCollectDT","collectDT","_this67$contract$meth","_this71$contract$meth","estCollectOceanFee","collectOceanFee","_this75$contract$meth","opcCollector","getRouter","router","getExchangeOwner","_this81$getExchange","exchangeOwner","estUpdateMarketFee","newMarketFee","updateMarketFee","_this85$contract$meth","estUpdateMarketFeeCollector","newMarketFeeCollector","updateMarketFeeCollector","_this89$contract$meth","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","estGasCreateErc20","nftAddress","nftContract","createERC20","createErc20","getNftPermissions","_this3$getNftPermissi","deployERC20","_nftContract$methods$2","events","TokenCreated","returnValues","estGasAddManager","manager","addManager","getNftOwner","_this7$getNftOwner","_nftContract$methods$4","estGasRemoveManager","removeManager","_this11$getNftOwner","_nftContract$methods$6","estGasAddErc20Deployer","erc20Deployer","addToCreateERC20List","addErc20Deployer","_this15$getNftPermiss","_nftContract$methods$8","estGasRemoveErc20Deployer","removeFromCreateErc20List","removeErc20Deployer","_temp11","_this19$getNftPermiss2","removeFromCreateERC20List","_nftContract$methods$10","_this19$getNftPermiss","estGasAddMetadataUpdater","metadataUpdater","addToMetadataList","addMetadataUpdater","_this23$getNftPermiss","_nftContract$methods$12","esGasRemoveMetadataUpdater","removeFromMetadataList","removeMetadataUpdater","_temp17","_this27$getNftPermiss2","updateMetadata","_nftContract$methods$14","_this27$getNftPermiss","estGasAddStoreUpdater","storeUpdater","addTo725StoreList","addStoreUpdater","_this31$getNftPermiss","_nftContract$methods$16","estGasRemoveStoreUpdater","removeFrom725StoreList","removeStoreUpdater","_temp23","_this35$getNftPermiss2","store","_nftContract$methods$18","_this35$getNftPermiss","estGasCleanPermissions","cleanPermissions","_this39$getNftOwner","_nftContract$methods$20","estGasTransferNft","nftOwner","nftReceiver","tokenId","transferFrom","transferNft","_this43$getNftOwner","tokenIdentifier","_nftContract$methods$22","estGasSafeTransferNft","safeTransferFrom","safeTransferNft","_this47$getNftOwner","_nftContract$methods$24","estGasSetMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","data","metadataHash","metadataProofs","setMetaData","setMetadata","_this51$getNftPermiss","_nftContract$methods$26","estGasSetMetadataAndTokenURI","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataAndTokenURI","_this55$getNftPermiss","_nftContract$methods$28","estGasSetMetadataState","setMetaDataState","setMetadataState","_this59$getNftPermiss","_nftContract$methods$30","estSetTokenURI","setTokenURI","_nftContract$methods$32","ownerOf","getPermissions","getMetadata","getMetaData","isErc20Deployer","isERC20Deployer","key","getTokenURI","id","tokenURI","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","estGasApprove","dtContract","_dtContract$methods$a2","estGasMint","toAddress","mint","estGasCreateFixedRate","fixedRateParams","createFixedRate","_dtContract$methods$c2","estGasCreateDispenser","dispenserParams","createDispenser","_dtContract$methods$c4","getDTPermissions","_this15$getDTPermissi","getCap","capAvailble","gte","_dtContract$methods$m2","estGasAddMinter","addMinter","_this19$isERC20Deploy","_dtContract$methods$a4","estGasRemoveMinter","removeMinter","_this23$isERC20Deploy","_dtContract$methods$r2","estGasAddPaymentManager","paymentManager","addPaymentManager","_this27$isERC20Deploy","_dtContract$methods$a6","estGasRemovePaymentManager","removePaymentManager","_this31$isERC20Deploy","_dtContract$methods$r4","estGasSetPaymentCollector","setPaymentCollector","nftPermissions","isPaymentManager","isNftOwner","_dtContract$methods$s2","_this35$nft$getNftOwn","_this35$getDTPermissi","getNFTAddress","getPaymentCollector","transfer","weiAmount","transferWei","estGasTransfer","_dtContract$methods$t2","estGasStartOrder","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","getPublishingMarketFee","publishMarketFee","_dtContract$methods$s4","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","getCurrentAllownceTokens","currentAllowance","all","estGasBuyFromFreAndOrder","orderParams","buyFromFreAndOrder","freContractParams","_dtContract$methods$b2","estGasBuyFromDispenserAndOrder","buyFromDispenserAndOrder","_dtContract$methods$b4","estGasSetData","value","setData","_dtContract$methods$s6","_this63$nft2","_this63$nft$getNftOwn","_dtContract$methods$c6","permissions","getDecimals","getERC721Address","addressZERO","NftFactory","factory721","defaultFactory721Abi","estGasCreateNFT","nftData","deployERC721Contract","transferable","createNFT","getCurrentNFTTemplateCount","_nftData$templateInde2","getNFTTemplate","_this3$getNFTTemplate","_this3$factory721$met","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getOwner","getCurrentTokenTemplateCount","getCurrentTemplateCount","index","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","estGasAddNFTTemplate","templateAddress","add721TokenTemplate","addNFTTemplate","_this25$getOwner","_this25$factory721$me","estGasDisableNFTTemplate","disable721TokenTemplate","disableNFTTemplate","_this29$getOwner","_this29$factory721$me","estGasReactivateNFTTemplate","reactivate721TokenTemplate","reactivateNFTTemplate","_this33$getOwner","_this33$factory721$me","estGasAddTokenTemplate","addTokenTemplate","_this37$getOwner","_this37$factory721$me","estGasDisableTokenTemplate","disableTokenTemplate","_this41$getOwner","_this41$getTokenTempl","_this41$factory721$me","estGasReactivateTokenTemplate","reactivateTokenTemplate","_this45$getOwner","_this45$getTokenTempl","_this45$factory721$me","estGasStartMultipleTokenOrder","orders","startMultipleTokenOrder","_this49$factory721$me","estGasCreateNftWithErc20","nftCreateData","ercCreateData","createNftWithErc20","_this53$factory721$me","estGasCreateNftErc20WithPool","poolData","createNftWithErc20WithPool","createNftErc20WithPool","_this57$factory721$me","estGasCreateNftErc20WithFixedRate","fixedData","createNftWithErc20WithFixedRate","createNftErc20WithFixedRate","_this61$factory721$me","estGasCreateNftErc20WithDispenser","createNftWithErc20WithDispenser","createNftErc20WithDispenser","_this65$factory721$me","noZeroX","input","zeroOutput","regexp","conversorName","match","output","inputMatch","zeroXTransformer","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","createSignature","accountId","agreementId","createHashSignature","encrypt","checkDidFiles","serviceId","args","files","results","checkFileUrl","getComputeEnvironments","_this10$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","algorithm","additionalDatasets","computeStartUrl","signatureMessage","documentId","payload","Object","environment","statusText","params","computeStop","jobId","computeStopUrl","computeStatus","computeStatusUrl","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","isValidProvider","providerAddress","ProviderInstance","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","force","_tokenContract$method3","currentAllowence","filename","get","split","pop","arrayBuffer","anchor","document","createElement","download","href","click","opts","_error2","erc721Address","toChecksumAddress","sha256","postWithHeaders","signedMessage","substr","slice"],"mappings":"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"}